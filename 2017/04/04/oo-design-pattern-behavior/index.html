<!DOCTYPE html>
<html lang="en">
<head>

  <meta charset="utf-8" />

  
  <title>[设计模式]行为型模式</title>

  
  




  
  <meta name="author" content="wukn" />
  <meta name="description" content=" 行为型模式用于处理类或对象的交互和职责分配。
 
" />

  
  
    <meta name="twitter:card" content="summary" />
    <meta name="twitter:site" content="@gohugoio" />
    <meta name="twitter:title" content="[设计模式]行为型模式" />
    <meta name="twitter:description" content=" 行为型模式用于处理类或对象的交互和职责分配。
 
" />
    <meta name="twitter:image" content="https://wukn.github.io/img/avatar.jpg" />
  




<meta name="generator" content="Hugo 0.29" />


<link rel="canonical" href="https://wukn.github.io/2017/04/04/oo-design-pattern-behavior/" />
<link rel="alternative" href="https://wukn.github.io/index.xml" title="wukn blog" type="application/atom+xml" />


<meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<meta name="format-detection" content="telephone=no,email=no,adress=no" />
<meta http-equiv="Cache-Control" content="no-transform" />


<meta name="robots" content="index,follow" />
<meta name="referrer" content="origin-when-cross-origin" />







<meta name="apple-mobile-web-app-capable" content="yes" />
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
<meta name="apple-mobile-web-app-title" content="wukn blog" />
<meta name="msapplication-tooltip" content="wukn blog" />
<meta name='msapplication-navbutton-color' content="#5fbf5e" />
<meta name="msapplication-TileColor" content="#5fbf5e" />
<meta name="msapplication-TileImage" content="/img/tile-image-windows.png" />
<link rel="icon" href="https://wukn.github.io/img/favicon.ico" />
<link rel="icon" type="image/png" sizes="16x16" href="https://wukn.github.io/img/favicon-16x16.png" />
<link rel="icon" type="image/png" sizes="32x32" href="https://wukn.github.io/img/favicon-32x32.png" />
<link rel="icon" sizes="192x192" href="https://wukn.github.io/img/touch-icon-android.png" />
<link rel="apple-touch-icon" href="https://wukn.github.io/img/touch-icon-apple.png" />
<link rel="mask-icon" href="https://wukn.github.io/img/safari-pinned-tab.svg" color="#5fbf5e" />



<link rel="stylesheet" href="//cdn.bootcss.com/video.js/6.2.8/alt/video-js-cdn.min.css" />

<link rel="stylesheet" href="https://wukn.github.io/css/bundle.css" />


  
  <!--[if lt IE 9]>
    <script src="//cdn.bootcss.com/html5shiv/3.7.3/html5shiv.min.js"></script>
    <script src="//cdn.bootcss.com/respond.js/1.4.2/respond.min.js"></script>
    <script src="//cdn.bootcss.com/video.js/6.2.8/ie8/videojs-ie8.min.js"></script>
  <![endif]-->

<!--[if lte IE 11]>
    <script src="//cdn.bootcss.com/classlist/1.1.20170427/classList.min.js"></script>
  <![endif]-->


<script src="//cdn.bootcss.com/object-fit-images/3.2.3/ofi.min.js"></script>


<script src="//cdn.bootcss.com/smooth-scroll/12.1.4/js/smooth-scroll.polyfills.min.js"></script>


</head>
  <body>
    
    <div class="suspension">
      <a title="Go to top" class="to-top is-hide"><span class="icon icon-up"></span></a>
      
        
      
    </div>
    
    
  <header class="site-header">
  <img class="avatar" src="https://wukn.github.io/img/avatar.jpg" alt="Avatar">
  
  <h2 class="title">wukn blog</h2>
  
  <p class="subtitle">~ Stay Hungry, Stay Foolish ~</p>
  <button class="menu-toggle" type="button">
    <span class="icon icon-menu"></span>
  </button>
  <nav class="site-menu collapsed">
    <h2 class="offscreen">Main Menu</h2>
    <ul class="menu-list">
      
      
      
      
        <li class="menu-item  is-active"><a href="https://wukn.github.io/">Home</a></li>
      
        <li class="menu-item "><a href="https://github.com/wukn">Works</a></li>
      
        <li class="menu-item "><a href="https://wukn.github.io/tags">Tags</a></li>
      
        <li class="menu-item "><a href="https://wukn.github.io/about/">About</a></li>
      
    </ul>
  </nav>
  <nav class="social-menu collapsed">
    <h2 class="offscreen">Social Networks</h2>
    <ul class="social-list">

      

      
      <li class="social-item">
        <a href="//github.com/wukn" title="GitHub"><span class="icon icon-github"></span></a>
      </li>

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      <li class="social-item">
        <a href="https://wukn.github.io/img/wechat_qrcode.png" title="Wechat"><span class="icon icon-wechat"></span></a>
      </li>

      

      

      

      

      <li class="social-item">
        <a href="https://wukn.github.io/index.xml"><span class="icon icon-rss" title="RSS"></span></a>
      </li>

    </ul>
  </nav>
</header>

  <section class="main post-detail">
    <header class="post-header">
      <h1 class="post-title">[设计模式]行为型模式</h1>
      <p class="post-meta">@wukn · Apr 4, 2017 · 1 min read</p>
    </header>
    <article class="post-content"><blockquote>
<p>行为型模式用于处理类或对象的交互和职责分配。</p>
</blockquote>

<p></p>

<h3 id="interpreter-解释器模式">Interpreter（解释器模式）</h3>

<p>意图：给定一个语言及它的文法，并创建一个解释器，该解释器使用该文法来解释该语言的句子。</p>

<p>设计原则：遵循单一职责</p>

<p>当有一个语言需要解释执行，并且可将该语言中的句子表示为一个抽象语法树时，可使用解释器模式。</p>

<p><img src="https://wukn.github.io/img/post/design-pattern/interpreter.png" alt="" /></p>

<p>AbstractExpression（抽象表达式）声明一个抽象的解释操作，这个接口为抽象语法树中所有的节点共享。TerminalExpression（终结符表达式）实现与文法中的终结符相关联的解释操作；一个句子中的每个终结符需要该类的一个实例。对于文法中每一条规则都需要一个NonterminalExpression（非终结符表达式）类，它为每个符号都维护一个AbstractExpression类型的实例变量；它为文法中的非终结符实现解释操作，解释一般要递归地调用表示规则的那些对象的解释操作。Context（上下文）包含解释器之外的一些全局信息。</p>

<p>Client构建或被给定表示该文法定义的语言中一个特定的句子的抽象语法树。该抽象语法树由NonterminalExpression和TerminalExpression的实例装配而成。Client初始化上下文并调用解释操作。每一个非终结符表达式节点定义相应子表达式的解释操作，而各终结符表达式的解释操作构成了递归的基础。每个节点的解释操作用上下文来存储和访问解释器的状态。</p>

<h3 id="template-method-模板方法模式">Template Method（模板方法模式）</h3>

<p>意图：定义算法的骨架，将一些步骤的实现延迟到子类中。模板方法模式使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。</p>

<p>设计原则：破坏里氏替换，体现功能复用</p>

<p>模板方法适用于下列情况：</p>

<ul>
<li>一次性实现一个算法的不变的部分，并将可变的行为留给子类来实现。</li>
<li>各子类中公共的行为应被提取出来并集中到一个公共父类中以避免代码重复。</li>
<li>控制子类扩展。</li>
</ul>

<p><img src="https://wukn.github.io/img/post/design-pattern/template-method.png" alt="" /></p>

<p>AbstractClass（抽象类）定义抽象的原语操作（primitive operation），具体的子类将重新定义它们以实现一个算法的各步骤；同时实现一个模板方法，定义一个算法的骨架，该模板方法不仅调用原语操作，也调用定义在AbstractClass或其它对象中的操作。ConcreteClass（具体类）实现原语操作以完成算法中与特定子类相关的步骤。</p>

<p>模板方法是一种代码复用的基本技术。它导致一种反向的控制结构。这种结构有时被成为“好莱坞原则”，即”别找我们，我们找你”。这指的是一个父类调用一个子类的方法。</p>

<h3 id="chain-of-responsibility-职责链模式">Chain of Responsibility（职责链模式）</h3>

<p>意图：为了解除请求者和接收者的耦合，使多个对象都有机会处理该请求，将多个对象串成一条链，使请求通过链上的每个对象，各对象根据自己的需求来处理请求。</p>

<p>设计原则：遵循迪米特</p>

<p>在以下条件下使用职责链模式：</p>

<ul>
<li>有多个对象可以处理一个请求，哪个对象处理该请求在运行时刻自动确定。</li>
<li>想在不明确指定接受者的情况下，向多个对象中的一个提交一个请求。</li>
<li>可以处理一个请求的对象集合应被动态指定。</li>
</ul>

<p><img src="https://wukn.github.io/img/post/design-pattern/chain-of-responsibility.png" alt="" /></p>

<p>Handler定义一个处理请求的接口，（可选）实现后继链。ConcreteHandler处理它所负责的请求；它可以访问它的后继者，如果可处理该请求，就处理之，否则就将该请求转发给它的后继者。</p>

<p>Client提交一个请求时，请求沿链传递直至有一个ConcreteHandler对象负责处理它。</p>

<p>职责链能狗降低耦合度，它使得一个对象无需知道是其他哪一个对象处理其请求。对象仅需知道请求会被“正确”地处理。接收者和发送者都没有对方的明确信息，且链中的对象不知道链的结构。职责链简化了对象的相互连接。它们仅需保持一个后继者的引用。另外，可以在运行时刻对该链进行动态的增加或修改来增加或改变处理一个请求的那些职责。但是，由于请求没有明确的接收者，那么就不能保证它一定会被处理。</p>

<h3 id="command-命令模式">Command（命令模式）</h3>

<p>意图：将请求封装成对象，从而可以用不同的请求对客户进行参数化，并可以使请求排队，记录请求日志以及取消请求。</p>

<p>设计原则：遵循迪米特、开闭原则</p>

<p>命令模式跟职责链模式类似，都是为了处理请求或者命令而存在的，而且二者都是为了将请求者与响应者解耦。不同的是命令模式中，客户端需要知道一个命令的接收者，在创建命令的时候就把接收者与命令绑定在一起发送给调用者；而职责链模式中，客户端并不关心最终处理请求的对象是谁，客户端只是封装一个请求对象，随后交给职责链的头部而已，因此两者的实现方式有较大的区别。</p>

<p><img src="https://wukn.github.io/img/post/design-pattern/command.png" alt="" /></p>

<p>Command声明执行操作的接口。ConcreteCommand将一个接收者对象绑定于一个动作，调用接收者相应的操作，以实现Execute。Client创建一个具体命令对象并设定它的接收者。Invoker要求该命令执行这个请求。Reveiver知道如何实施与执行一个请求相关的操作。任何类都可能作为一个接收者。</p>

<p>Client创建一个ConvreteCommand对象并指定它的Receiver对象。某Invoker对象存储该ConcreteCommand对象。该Invoker通过调用Command对象的Execute操作来提交一个请求。若该命令是可撤销的，ConcreteCommand就在执行Execute操作之前存储当前状态以用于取消该命令。ConcreteCommand对象调用它的Receiver的一些操作以执行该请求。</p>

<p>命令模式将调用操作的对象与知道如何实现该操作的对象解耦。</p>

<h3 id="iterator-迭代器模式">Iterator（迭代器模式）</h3>

<p>意图：提供一种方法可以顺序访问一个聚合对象中的各个元素，而无需暴露该对象的内部表示。</p>

<p>设计原则：遵循迪米特</p>

<p>跟访问者模式相比，二者都是迭代的访问一个聚合对象中的各个元素。不同的是，访问者模式中，扩展开放的部分在作用于对象的操作上，而迭代器模式中，扩展开放的部分在聚合对象的种类上。</p>

<p>迭代器模式可用来：</p>

<ul>
<li>访问一个聚合对象的内容而无需暴露它的内部表示。</li>
<li>支持对聚合对象的多种遍历。</li>
<li>为遍历不同的聚合结构提供一个同意的接口（即，支持多态迭代）。</li>
</ul>

<p><img src="https://wukn.github.io/img/post/design-pattern/iterator.png" alt="" /></p>

<p>Iterator迭代器定义访问和遍历元素的接口。ConcreteIterator实现迭代器的接口，对聚合遍历时跟踪当前位置。Aggregate聚合定义创建相应迭代器对象的接口。ConcreteAggragate实现创建相应迭代器的接口，该操作返回ConcreteIterator的一个适当的实例。</p>

<p>ConcreteIterator跟踪聚合中的当前对象，并能够计算出待遍历的后继对象。</p>

<p>根据迭代的控制方是迭代器还是使用该迭代器的用户，分为内部迭代器和外部迭代器。使用外部迭代器的用户必须主动推进遍历的步伐，显式地向迭代器请求下一个元素。若使用内部迭代器，用户只需要向其提交一个待执行的操作，而迭代器将对聚合中的每一个元素实施该操作。</p>

<h3 id="mediator-中介者模式">Mediator（中介者模式）</h3>

<p>意图：封装各个对象的交互，从而使各个对象无需通过互相引用来交互，降低了各个对象的耦合度，并且可以独立地改变对象之间的交互而无需影响对象。</p>

<p>设计原则：遵循迪米特，破坏单一职责</p>

<p>在以下情况下使用中介者模式：</p>

<ul>
<li>一组对象以定义良好但是复杂的方式进行通信。产生的相互依赖关系结构混乱且难以理解。</li>
<li>一个对象引用其它很多对象并且直接与这些对象通信，导致难以复用该对象。</li>
<li>想定制一个分布在多个类中的行为，而又不想生成太多的子类。</li>
</ul>

<p><img src="https://wukn.github.io/img/post/design-pattern/mediator.png" alt="" /></p>

<p>Mediator（中介者）定义一个用于与各同事（Colleague）对象通信。ConcreteMediator通过协调各同事对象实现协作行为，它需要了解并维护它的各个同事。每一个同事类都知道它的中介者对象；每一个同事对象在需要与其他的同事通信的时候，与它的中介者通信。</p>

<p>同事向一个中介者对象发送和接收请求。中介者在各同事间适当地转发请求以实现协作行为。</p>

<p>中介者模式减少了子类的生成，它将原本分布于多个对象间的行为集中在一起。并且将各Colleague解耦。</p>

<h3 id="memento-备忘录模式">Memento（备忘录模式）</h3>

<p>意图：在不破坏封装性的前提下，可以获取一个对象的内部状态，并且把这个状态保存在对象之外，从而可以将对象恢复至这个状态。</p>

<p>设计原则：遵循迪米特、开闭原则</p>

<p>在以下情况使用备忘录模式：</p>

<ul>
<li>必须保存一个对象在某一时刻的（部分）状态，这样以后需要时它才能恢复到先前的状态。</li>
<li>如果一个用接口来让其它对象直接得到这些状态，将会暴露对象的实现细节并破坏对象的封装性。</li>
</ul>

<p><img src="https://wukn.github.io/img/post/design-pattern/memento.png" alt="" /></p>

<p>Memento（备忘录）存储原发器对象的内部状态。原发器根据需要决定备忘录存储原发器的哪些内部状态。防止原发器以外的其它对象访问备忘录。备忘录实际上有两个接口，管理者（caretaker）只能看到备忘录的窄接口，它只能将备忘录传递给其它对象。相反，原发器能够看到一个宽接口，允许它访问返回到先前状态所需的所有数据。理想的情况是只允许生成本备忘录的那个原发器访问本备忘录的内部状态。Originator（原发器）创建一个备忘录，用以记录当前时刻它的内部状态，它可以使用备忘录来恢复内部状态。Caretaker（负责人）负责保存好备忘录，它不能对备忘录的内容进行操作或检查。</p>

<p>使用备忘录可以避免暴露一些只应由原发器管理却又必须存储在原发器之外的信息，该模式把可能很复杂的Originator内部信息对其他对象屏蔽起来，从而保持了封装边界。</p>

<h3 id="observer-观察者模式">Observer（观察者模式）</h3>

<p>意图：定义对象之间一种一对多的依赖关系，以便于在对象发生变化时，所有依赖于它的对象都得到通知并被自动更新。</p>

<p>设计原则：遵循迪米特、开闭原则</p>

<p>在以下任一情况下可以使用观察者模式：</p>

<ul>
<li>当一个抽象模型有两个方面，其中一方面依赖于另一方面。将这二者封装在独立的对象中以使它们可以各自独立地改变和复用。</li>
<li>当对一个对象的改变需要同时改变其它对象，而不知道具体有多少对象有待改变。</li>
<li>当一个对象必须通知其它对象，而它又不能假定其它对象是谁。换言之，不希望这些对象是紧密耦合的。</li>
</ul>

<p><img src="https://wukn.github.io/img/post/design-pattern/observer.png" alt="" /></p>

<p>Subject（目标）知道它的观察者，可以有任意多个观察者观察同一个目标。Subject提供注册和删除观察者对象的接口。Observer（观察者）为那些在目标发生改变时需获得通知的对象定义一个更新接口。ConcreteSubject将有关状态存入各ConcreteObserver对象，当它的状态发生改变时，向它的各个观察者发出通知。ConcreteObserver维护一个指向ConcreteObserver对象的引用；存储有关状态，这些状态应与目标的状态保持一致；实现Observer的更新接口以使自身状态与目标状态保持一致。</p>

<p>观察者模式允许独立地改变目标和观察者，实现了目标和观察者之间的抽象耦合。</p>

<p>当目标和观察者之间的依赖关系特别复杂时，可能需要一个维护这些关系的对象。这样的对象称为更改管理器（ChangeManager）。它的目的是尽量减少观察者反映其目标的状态变化所需的工作量。例如，如果一个操作涉及到对几个相互依赖的目标进行改动，就必须保证仅在所有的目标都已更改完毕后，才一次性地通知它们的观察者，而不是每个目标都通知观察者。</p>

<p>ChangeManager有三个责任：</p>

<ul>
<li>它将一个目标映射到它的观察者并提供一个接口来维护这个映射。这就不需要由目标来维护对其观察者的引用，反之亦然。</li>
<li>它定义一个特定的更新策略。</li>
<li>根据一个目标的请求，它更新所有依赖于这个目标的观察者。</li>
</ul>

<p><img src="https://wukn.github.io/img/post/design-pattern/observer2.png" alt="" /></p>

<p>有两种特殊的ChangeManager。SimpleChangeManager总是更新每一个目标的所有观察者，比较简单。DAGChangeManager处理目标及其观察者之间依赖关系构成的无环有向图。当一个观察者观察多个目标时，DAGChangeManager比SimpleChangeManager要好一些。在这种情况下，两个或更多个目标中产生的改变可能会产生冗余的更新，DAGChangeManager保证观察者仅接收一个更新。</p>

<p>ChangerManager是一个中介者模式的实例。通常只有一个ChangeManager，并且他是全局可见的。这就可能还会用到单例模式。</p>

<h3 id="state-状态模式">State（状态模式）</h3>

<p>意图：允许一个对象在其内部状态发生变化时改变它的行为，这使对象看起来似乎修改了它所属的类。</p>

<p>设计原则：遵循单一职责、依赖倒置、开闭原则</p>

<p>状态模式与策略模式的实现方式非常相似，策略接口与状态接口，具体的策略与具体的状态以及二者都拥有的上下文。如果看它们的类图，会发现几乎一模一样，而二者不同的地方就在于，状态模式经常会在处理请求的过程中更改上下文的状态，而策略模式只是按照不同的算法处理算法逻辑。从实际场景来讲，顾名思义，状态模式改变的是状态，策略模式改变的是策略。</p>

<p>在以下两种情况下均可使用状态模式：</p>

<ul>
<li>一个对象的行为取决于它的状态，并且它必须在运行时刻根据状态改变它的行为。</li>
<li>一个操作中含有庞大的多分支条件语句，且这些分支依赖于该对象的状态。这个状态通常用一个或多个枚举常量表示。通常，有多个操作包含这一相同的条件结构。状态模式将每一个条件分支放入一个独立的类中。这使得我们可以根据对象自身的情况将对象的状态作为一个对象，这一对象可以不依赖于其它对象而独立变化。</li>
</ul>

<p><img src="https://wukn.github.io/img/post/design-pattern/state.png" alt="" /></p>

<p>Context定义用户感兴趣的接口；它维护一个ConcreteState子类的实例，这个实例定义当前状态。State定义一个接口以封装与Context的一个特定状态相关的行为。每一个ConcreteState子类实现一个与Context的一个状态相关的行为。</p>

<p>Context将与状态相关的请求委托给当前的ConcreteState对象处理。Concext可将自身作为一个参数传递给处理该请求的状态对象，这使得对象状态在必要时可访问Context。Concext是用户使用的主要接口，用户可用状态对象来配置一个Context，一旦一个Context配置完毕，它的用户不再需要直接与对象状态打交道。Context和ConcreteState子类都可决定哪个状态是另外哪一个的后继者，以及是在何种条件下进行状态转换。</p>

<h3 id="strategy-策略模式">Strategy（策略模式）</h3>

<p>意图：封装算法，从而可以使算法独立变化而不影响其它对象。</p>

<p>设计原则：遵循单一职责、依赖倒置、迪米特、开闭原则</p>

<p>当存在以下情况时使用策略模式：</p>

<ul>
<li>许多相关的类仅仅是行为有异。“策略”提供了一种多个行为中的一个行为来配置一个类的方法。</li>
<li>需要使用一个算法的不同变体。</li>
<li>算法使用用户不应该知道的数据，可使用策略模式以避免暴露复杂的、与算法相关的数据结构。</li>
<li>一个类定义了多种行为，并且这些行为在这个类的操作中以多个条件语句的形式出现。将相关的条件分支移入它们各自的Strategy类中以代替这些条件语句。</li>
</ul>

<p><img src="https://wukn.github.io/img/post/design-pattern/strategy.png" alt="" /></p>

<p>Strategy定义所有支持的算法的公共接口。Context使用这个接口来调用某concreteStrategy定义的算法。ConcreteStrategy以Stategy接口实现某具体算法。Context用一个ConcreteStrategy对象来配置，它需要维护一个对Stategy对象的引用，可以定义一个接口来让Strategy访问它的数据。</p>

<p>Strategy和Context相互作用以实现选定的算法。当算法被调用时，Context可以将该算法所需要的所有数据都传递给该Strategy。或者，Context可以将自身作为一个参数传递给Strategy操作。这就让Strategy在需要时可以回调Context。Context将它的用户的请求转发给它的Strategy。用户通常创建并传递一个ConcreteStrategy对象给该Context；这样，用户仅与Context交互。通常有一系列的ConcreteStrategy可供用户选择。</p>

<h3 id="visitor-访问者模式">Visitor（访问者模式）</h3>

<p>意图：定义作用于对象中各元素的操作，可以在不改变各元素的类的前提下，定义作用于这些元素的新操作。</p>

<p>设计原则：遵循倾斜的开闭原则</p>

<p>在下列情况下使用访问者模式：</p>

<ul>
<li>一个对象结构包含很多类对象，他们有不同的接口，而我们想对这些对象实施一些依赖于其具体类的操作。</li>
<li>需要对一个对象结构中的对象进行很多不同的并且不相关的操作，而我们想避免让这些操作”污染”这些对象的类。访问者模式可以将相关的操作集中起来定义在一个类中。当该对象结构被很多应用共享时，用访问者模式让每个应用仅包含需要用到的操作。</li>
<li>定义对象结构的类很少改变，但经常需要在此结构上定义新的操作。改变对象结构类需要重定义对所有访问者的接口，这可能需要很大的代价。如果对象结构类经常改变，那么可能还是在这些类中定义这些操作比较好。</li>
</ul>

<p><img src="https://wukn.github.io/img/post/design-pattern/visitor.png" alt="" /></p>

<p>Visitor为该对象结构中ConcreteElement的每一个类声明一个Visit操作，该操作的名字和特征标识了发送Visit请求给该访问者的哪个类。这使得访问者可以确定正被访问元素的具体的类。这样访问者就可以通过该元素的特定接口直接访问它。ConcreteVisitor实现每个由Visitor声明的操作。每个操作实现本算法的一部分，而该算法片段乃是对应于结构中对象的类。ConcreteVisitor为该算法提提供了上下文并存储它的局部状态。Element定义了一个Accept操作，它以一个Visitor作为参数。ConcreteElement实现Accept操作。ObjectStructure能枚举它的元素，它可以提供一个高层的接口以允许该访问者访问它的元素，它可以是一个复合对象或是一个集合。</p>

<p>一个使用访问者模式的用户必须创建一个ConcreteVisitor对象，然后遍历该对象结构，并用该访问者访问每一个元素。当一个元素被访问时，它调用对应于它的类的Visitor操作。如有必要，该元素将自身作为这个操作的一个参数以便该访问者访问它的状态。</p>

<p>访问者模式使得易于增加新的操作。访问者集中相关的操作而分离无关的操作。但是使得增加新的ConcreteElement类很难。</p>

<h3 id="总结">总结</h3>

<p>封装变化是很多行为模式的主题。当一个程序的某个方面的特征经常发生改变时，这些模式就定义一个封装这个方面的对象。这样当程序的其他部分依赖于这个方面时，它们呢都可以与此对象协作。这些模式通常定义一个抽象类来描述这些封装变化的对象，并且通常该模式一句这个对象来命令：</p>

<ul>
<li>一个Strategy对象封装一个算法。</li>
<li>一个State对象封装一个与状态相关的行为。</li>
<li>一个Mediator对象封装对象间的协议。</li>
<li>一个Iterator对象封装访问和遍历一个聚集对象中的各个构件的方法。</li>
</ul>

<p>并非所有模式都定义类之间的静态通信关系。职责链模式与它们则不同，它提供在数目可变的对象间进行通信的机制。</p>

<p>还有一些模式涉及到一些作为参数传递的对象。例如访问者模式，一个Visitor对象是一个多态的Accept操作的参数，这个操作作用于该Visitor对象访问的对象。其它模式定义一些可作为令牌到处传递的对象，这些对象在稍后被调用。命令模式和备忘录模式都属于这一类。命令模式中，令牌代表一个请求；而在备忘录模式中，它代表在一个对象在某个特定时刻的内部状态。</p>

<p>中介者模式和观察者模式是相互竞争的。它们之间的差别是：观察者模式通过引入Observer和Subject对象来分布通信，而Mediator对象则封装了其他对象间的通信。</p>

<p>当合作的对象直接互相引用时，它们变得互相依赖，这可能会对一个系统的分层和重用性产生负面影响。命令模式、观察者模式、中介者模式和职责链模式等都涉及了如何对发送者和接收者解耦，但它们又各有不同的权衡考虑。命令模式使用一个Command对象来定义一个发送者和一个接收者之间的绑定关系，从而支持解耦。观察者模式通过定义一个接口来通知目标中发生的改变，从而将发送者（目标）与接收者（观察者）解耦。中介者模式让对象通过一个Mediator对象间接的互相引用，从而对它们解耦。职责链模式通过沿一个潜在接收者链传递请求而将发送者与接收者解耦。</p>

<hr />

<p>参考资料：</p>

<p>《设计模式：可复用面向对象软件的基础》</p>

<p>《大话设计模式》</p>

<p><a href="http://www.cnblogs.com/loofywang/p/MyUnderstandingOfDesignPattern1.html">对设计模式的认识</a></p>

<p><a href="http://www.cnblogs.com/zuoxiaolong/p/pattern26.html">设计模式大杂烩</a></p></article>
    <footer class="post-footer">
      
      <ul class="post-tags">
        
          <li><a href="https://wukn.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="tag">设计模式</span></a></li>
        
      </ul>
      
      <p class="post-copyright">
        © Creative Commons Attribution-NonCommercial 4.0 International License.This post was published <strong>193</strong> days ago, content in the post may be inaccurate, even wrong now, please take risk yourself.
      </p>
    </footer>
    
      
    
  </section>
  <footer class="site-footer">
  <p>© 2017 wukn blog</p>
  <p>Powered by <a href="https://gohugo.io/" target="_blank">Hugo</a> with theme <a href="https://github.com/laozhu/hugo-nuo" target="_blank">Nuo</a>.</p>
  
</footer>



<script async src="//cdn.bootcss.com/video.js/6.2.8/alt/video.novtt.min.js"></script>


<script src="https://wukn.github.io/js/bundle.js"></script>


<script>
window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
ga('create', 'UA-XXXXXXXX-X', 'auto');
ga('send', 'pageview');
</script>
<script async src='//www.google-analytics.com/analytics.js'></script>





  </body>
</html>
