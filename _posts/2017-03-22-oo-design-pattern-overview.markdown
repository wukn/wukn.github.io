---
layout:     post
title:      "[设计模式]总览"
subtitle:   ""
date:       2017-03-22 00:00:00
author:     "wukn"
header-img: ""
catalog: true
tags:
    - 设计模式

---

> 设计模式是把过去成功的并且被重复使用的设计经验以人们能够有效利用的方式记录下来。

在软件工程中，设计模式（Design Pattern）是对软件设计中普遍存在（反复出现）的各种问题，所提出的解决方案。设计模式并不是直接用来完成代码的编写的，而是描述在各种不同情况下，要怎样解决问题的一种方案。

![](/img/post/design-pattern/design-pattern.png)

创建型模式用于处理对象的创建；结构型模式用于处理类或对象的组合；行为型模式用于处理类或对象的交互和职责分配。

### 创建型

用各种方法创建或组合各种类型的对象,并向对象的使用者隐藏对象的创建过程。

#### Singleton（单例模式）

保证一个类只有一个实例，并提供一个它实例的全局访问点。

#### Factory Method（工厂方法模式）

定义了一个创建对象的接口，由子类决定实例化哪个类，使一个类的实例化延迟到其子类。

设计原则：遵循单一职责、依赖倒置、开闭原则

#### Abstract Factory（抽象工厂模式）

提供一个创建一系列相关或者相互依赖的对象的接口，但无需指定它们具体的类。

设计原则：遵循单一职责、依赖倒置、开闭原则

工厂方法模式与抽象工厂模式最大的区别在于，在工厂方法模式中，工厂创造的是一个产品，而在抽象工厂模式中，工厂创造的是一个产品族。

#### Builder（建造者模式）

将一个复杂的对象的构建和它的表示分离，从而使相同的构建过程可以创建不同的表示。

设计原则：遵循单一职责、开闭原则

建造者模式是为了复用对象的构建过程，而抽象工厂模式是为了提供这批对象的创建接口而定义了抽象工厂接口。

#### Prototype（原型模式）

用原型实例来指定对象的类型，并且通过拷贝这个原型实例来创建对象。

需要注意浅拷贝和深拷贝。

### 结构型

#### Proxy（代理模式）

为某个被访问对象提供代理，以控制所有对它的访问。

设计原则：体现功能复用

需要修改或屏蔽某一个或若干个类的部分功能，复用另外一部分功能，可使用静态代理。若是需要拦截一批类中的某些方法，在方法的前后插入一些一致的操作，假设这些类有一致的接口，可使用JDK的动态代理或cglib。（动态代理没看过啊，Hibernate中好像用到了吧）

#### Adapter（适配器模式）

将一个类的接口转换成用户希望的另一个接口，从而使原本因接口不兼容无法一起工作的类可以一起工作。

设计原则：遵循开闭原则、体现功能复用

对于适配器模式当中的定制适配器，它与静态代理有着相似的部分，二者都有复用功能的作用。不同的是，静态代理会修改一部分原有的功能，而适配器往往是全部复用，且在复用的同时，适配器还会为复用的类适配一个接口。

#### Decorator（装饰器模式）

动态地给对象添加额外的职责，比生成子类更加灵活。

设计原则：遵循迪米特、单一职责、开闭原则，破坏里氏替换，体现功能复用

对于适配器模式中的定制适配器与装饰器模式，二者都是使用组合加继承的手段，不同的是，适配器模式的目的在于适配接口，装饰器模式的目的在于动态的添加功能，且可以叠加。

#### Bridge（桥接模式）

将抽象部分和实现部分分离，从而使它们可以独立变化。

设计原则：遵循单一职责、迪米特、开闭原则，体现功能复用

#### Composite（组合模式）

将对象组合成树形结构以表示“整体-部分”的层次结构，从而使客户对于单个对象和组合对象的使用具有一致性。

设计原则：遵循依赖倒置、开闭原则，破坏接口隔离

#### Facade（外观模式）

为子系统中的一组接口提供一个一致的界面（即一个高层接口），从而使子系统更加容易使用。

设计原则：遵循迪米特

外观模式跟中介者模式很类似，都是为了处理复杂的耦合关系，不同的是外观模式处理的是类之间复杂的依赖关系，中介者模式处理的是对象之间复杂的交互关系。

#### Flyweight（享元模式）

运用共享技术有效地支持大量的细粒度对象。

### 行为型

#### Interpreter（解释器模式）

给定一个语言及它的文法，并创建一个解释器，该解释器使用该文法来解释该语言的句子。

设计原则：遵循单一职责

#### Template Method（模板方法模式）

定义算法的骨架，将一些步骤的实现交给子类解决。

设计原则：破坏里氏替换，体现功能复用

#### Chain of Responsibility（职责链模式）

为了解除请求者和接收者的耦合，使多个对象都有机会处理该请求，将多个对象串成一条链，使请求通过链上的每个对象，各对象根据自己的需求来处理请求。

设计原则：遵循迪米特

#### Command（命令模式）

将请求封装成对象，从而可以用不同的请求对客户进行参数化，并可以使请求排队，记录请求日志以及取消请求。

设计原则：遵循迪米特、开闭原则

命令模式跟职责链模式类似，都是为了处理请求或者命令而存在的，而且二者都是为了将请求者与响应者解耦。不同的是命令模式中，客户端需要知道一个命令的接收者，在创建命令的时候就把接收者与命令绑定在一起发送给调用者；而职责链模式中，客户端并不关心最终处理请求的对象是谁，客户端只是封装一个请求对象，随后交给职责链的头部而已，因此两者的实现方式有较大的区别。

#### Iterator（迭代器模式）

提供一种方法可以顺序访问一个聚合对象中的各个元素，而无需暴露该对象的内部表示。

设计原则：遵循迪米特

跟访问者模式相比，二者都是迭代的访问一个聚合对象中的各个元素。不同的是，访问者模式中，扩展开放的部分在作用于对象的操作上，而迭代器模式中，扩展开放的部分在聚合对象的种类上。

#### Mediator（中介者模式）

封装各个对象的交互，从而使各个对象无需通过互相引用来交互，降低了各个对象的耦合度，并且可以独立地改变对象之间的交互而无需影响对象。

设计原则：遵循迪米特，破坏单一职责

#### Memento（备忘录模式）

在不破坏封装性的前提下，可以获取一个对象的内部状态，并且把这个状态保存在对象之外，从而可以将对象恢复至这个状态。

设计原则：遵循迪米特、开闭原则

#### Observer（观察者模式）

定义对象之间一种一对多的依赖关系，以便于在对象发生变化时，可以及时通知到依赖于它的其他对象并使它们发生相应变化。

设计原则：遵循迪米特、开闭原则

#### State（状态模式）

允许一个对象在其内部状态发生变化时改变它的行为，这使对象看起来似乎修改了它所属的类。

设计原则：遵循单一职责、依赖倒置、开闭原则

状态模式与策略模式的实现方式非常相似，策略接口与状态接口，具体的策略与具体的状态以及二者都拥有的上下文。如果看它们的类图，会发现几乎一模一样，而二者不同的地方就在于，状态模式经常会在处理请求的过程中更改上下文的状态，而策略模式只是按照不同的算法处理算法逻辑。从实际场景来讲，顾名思义，状态模式改变的是状态，策略模式改变的是策略。

#### Strategy（策略模式）

封装算法，从而可以使算法独立变化而不影响其它对象。

设计原则：遵循单一职责、依赖倒置、迪米特、开闭原则

#### Visitor（访问者模式）

定义作用于对象中各元素的操作，可以在不改变各元素的类的前提下，定义作用于这些元素的新操作。

设计原则：遵循倾斜的开闭原则


---

参考资料：

《设计模式：可复用面向对象软件的基础》

《大话设计模式》

[对设计模式的认识](http://www.cnblogs.com/loofywang/p/MyUnderstandingOfDesignPattern1.html)

[设计模式大杂烩](http://www.cnblogs.com/zuoxiaolong/p/pattern26.html)
