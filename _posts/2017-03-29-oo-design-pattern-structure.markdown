---
layout:     post
title:      "[设计模式]结构型模式"
subtitle:   ""
date:       2017-03-29 00:00:00
author:     "wukn"
header-img: ""
catalog: true
tags:
    - 设计模式

---

> 结构型模式用于处理类或对象的组合。


### Proxy（代理模式）

意图：为某个被访问对象提供代理，以控制所有对它的访问。

设计原则：体现功能复用

代理对象和被代理的目标对象继承自同一个父类（便于用户操作，接口一致使代理对象看上去就和目标对象一样），并且包含被代理的目标对象，根据需求的不同增加了一些操作并限制了对目标对象的调用，比如安全性，数据完整性等，从而确保目标对象的调用符合需求。

需要修改或屏蔽某一个或若干个类的部分功能，复用另外一部分功能，可使用静态代理。若是需要拦截一批类中的某些方法，在方法的前后插入一些一致的操作，假设这些类有一致的接口，可使用JDK的动态代理或cglib。（动态代理没看过啊，Hibernate中好像用到了吧）

![](/img/post/design-pattern/proxy.png)

Proxy保存一个引用使得代理可以访问实体。若RealSubject和Subject接口相同，Proxy会引用Subject；Proxy具有与Subject的接口相同的接口；Proxy控制对实体的存取，并可能负责创建和删除它。Subject定义RealSubject和Proxy的共用接口，这样就能在任何使用RealSubject的地方使用Proxy。RealSubject为定义21Proxy所代表的实体。

Proxy模式在访问对象时引入了一定程度的间接性。

### Adapter（适配器模式）

意图：将一个类的接口转换成用户希望的另一个接口，从而使原本因接口不兼容无法一起工作的类可以一起工作。

设计原则：遵循开闭原则、体现功能复用

对于适配器模式当中的定制适配器，它与静态代理有着相似的部分，二者都有复用功能的作用。不同的是，静态代理会修改一部分原有的功能，而适配器往往是全部复用，且在复用的同时，适配器还会为复用的类适配一个接口。

以下场景适用适配器模式：

* 想使用一个已存在的类，而它的接口不符合需求
* 想创建一个可以复用的类，该类可以与其他不相关的类或不可预见的类（也就是那些接口不一定兼容的类）协同工作
* （仅适用于对象适配器）想使用一些已存在的子类，但是不可能对每一个都子类化以匹配它们的接口。对象适配器可以适配它的父类接口

类适配器使用多重继承对一个接口与另一个接口进行匹配：

![](/img/post/design-pattern/class-adapter.png)

对象适配器依赖于对象组合：

![](/img/post/design-pattern/object-adapter.png)

Target定义Client使用的与特定领域相关的接口。Client与符合Target接口的对象协同。Adaptee定义一个已存在的接口，这个接口需要适配。Adapter对Adaptee接口与Target接口进行适配。

类适配器用一个具体的Adapter类对Adaptee和Target进行匹配，结果是当我们想要匹配一个类以及它的所有子类时，类Adapter将不能胜任工作。类适配器使得Adapter可以重定义Adaptee的部分行为，因为Adapter是Adaptee的子类。

对象适配器则允许一个Adapter与多个Adaptee（即Adaptee及它的所有子类）同时工作。Adapter也可以一次给所有的Adaptee添加功能。使得重定义Adaptee的行为比较困难，需要生成Adaptee的子类并使得Adapter引用这个子类而不是Adaptee本身。

### Decorator（装饰器模式）

意图：动态地给对象添加额外的职责，比生成子类更加灵活。

设计原则：遵循迪米特、单一职责、开闭原则，破坏里氏替换，体现功能复用

适用于装饰器模式的场景：

* 在不影响其他对象的情况下，以动态、透明的方式给单个对象添加职责
* 处理那些可以撤销的职责
* 当不能采用生成子类的方法进行扩充时。一种情况是，可能有大量独立的扩展，为支持每一种组合将产生大量的子类，使得子类数目呈爆炸增长。另一种情况可能是因为类定义被隐藏，或类定义不能用于生成子类。

![](/img/post/design-pattern/decorator.png)

Component定义一个对象接口，可以给这些对象动态地添加职责。ConcreteComponent定义一个对象，可以给这个对象添加一些职责。Decorator记录一个指向Component对象的引用，并定义一个与Component接口一致的接口。ConcreteDecorator负责向组件添加职责。Decorator将请求转发给他的Component对象，并有可能在转发请求前后执行一些附加的动作。

对于适配器模式中的定制适配器与装饰器模式，二者都是使用组合加继承的手段，不同的是，适配器模式的目的在于适配接口，装饰器模式的目的在于动态的添加功能，且可以叠加。

与对象的静态继承相比，装饰器模式提供了更加灵活的向对象添加职责的方式。并可以在运行时刻添加和删除职责。相比之下，继承机制要求为每个添加的职责创建一个新的子类。这会产生许多新的类，并且会增加系统的复杂度。此外，为一个特定的Component类提供多个不同的Decorator类，使得可以对一些职责进行混合和匹配。

### Bridge（桥接模式）

意图：将抽象部分和实现部分分离，从而使它们可以独立变化。

设计原则：遵循单一职责、迪米特、开闭原则，体现功能复用

桥接模式与对象适配器相似，但出发点不同：桥接模式的目的是将接口部分和实现部分分离，从而对它们可以较为容易也相对独立的加以改变。而适配器模式则意味着改变一个已有对象的接口。

适用于桥接模式的场景：

* 不希望在抽象和它的实现部分之间有一个固定的绑定关系。这种情况可能是因为，在程序运行时刻实现部分应可以被选择或切换。
* 类的抽象以及它的实现都应该可以通过生成子类的方法进行扩充。这时桥接模式可以对不同的抽象接口和实现部分进行组合，并分别对它们进行补充。
* 对一个抽象的实现部分的修改应对用户不产生影响。
* 想在多个对象之间共享实现，但同时要求用户不知道这一点。

![](/img/post/design-pattern/bridge.png)

Abstration定义抽象类的接口，并维护一个指向Implementor类型对象的引用。RefinedAbstraction扩充由Abstration定义的接口。Implementor定义实现类的接口，该接口不一定要与Abstraction的接口完全一致，事实上这两个接口可以完全不同；一般来讲，Implementor接口仅提供基本的操作，而Abstraction则定义了基于这些基本操作的较高层次的操作。ConcreteImplementor实现Implementor接口并定义它的具体实现。

用户使用时，由Abstraction将client的请求转发给它的Implementor对象。

桥接模式具有接口与实现分离的优点。一个实现未必不变地绑定在一个接口上。抽象类的实现可以在运行时刻进行配置，一个对象甚至可以在运行时刻改变它的实现。将Abstraction和Implementor分离有助于降低对实现部分编译时刻的依赖性，当改变一个实现类时，并不需要重新编译Abstraction类和用户程序。另外，接口与实现分离有助于分层，系统的高层部分仅需知道Abstraction和Implementation即可。

桥接模式中，可以独立地对Abstraction和Implementor层次结构进行扩充。还可以对用户隐藏实现细节，例如共享Implementor对象以及相应的引用计数机制。

### Composite（组合模式）

意图：将对象组合成树形结构以表示“整体-部分”的层次结构，从而使客户对于单个对象和组合对象的使用具有一致性。

设计原则：遵循依赖倒置、开闭原则，破坏接口隔离

适用于组合模式的场景：

* 想表示对象的部分——整体层次结构。
* 希望用户忽略组合对象与单个对象的不同，用户将统一地使用组合结构中的所有对象。

![](/img/post/design-pattern/composite.png)

Component为组合中的对象声明接口，并在适当的情况下实现所有类共有接口的默认行为，（可选）在递归结构中定义一个接口用于访问一个父部件并在合适的情况下实现它。Leaf在组合中表示叶节点对象，叶节点没有子节点。Composite定义有子部件的那些部件的行为，它需要存储子部件，并在Component接口中实现与子部件有关的操作。

用户通过Component接口操作组合部件的对象。如果接收者是一个叶节点，则直接处理请求。如果接收者是Composite，它通常将请求发送给它的子部件，在转发请求前后可能执行一些辅助操作。

### Facade（外观模式）

意图：为子系统中的一组接口提供一个一致的界面（即一个高层接口），从而使子系统更加容易使用。

设计原则：遵循迪米特

将一个系统划分为若干个子系统有利于降低系统的复杂性。一个常见的设计目标是使子系统之间的通信和相互依赖关系达到最小。达到该目标的途径之一就是引入一个外观对象。

外观模式跟中介者模式很类似，都是为了处理复杂的耦合关系，不同的是外观模式处理的是类之间复杂的依赖关系，中介者模式处理的是对象之间复杂的交互关系。

![](/img/post/design-pattern/facade.png)

Facade类知道哪些子系统类负责处理请求，它将用户的请求代理给适当的子系统对象。子系统类对象负责实现子系统的功能，它们处理由Facade对象指派的任务。子系统对象没有facade的任何相关信息。

外观模式对用户屏蔽了子系统组件，因而减少了用户处理的对象的数量并使得子系统使用起来更加方便。它实现了子系统与用户之间的松耦合关系。

### Flyweight（享元模式）

意图：运用共享技术有效地支持大量的细粒度对象。

享元模式的有效性很大程度上取决于如何使用它以及在何处使用它。当一下情况都成立时使用享元模式：

* 应用程序使用了大量的对象
* 完全由于使用大量的对象，造成很大的内存开销
* 对象的大多数状态都可变为外部状态
* 如果删除对象的外部状态，那么可以用相对较少的共享对象取代很多组对象
* 应用程序不依赖于对象标识

![](/img/post/design-pattern/flyweight.png)

Flyweight描述一个接口，通过这个接口flyweight可以接受并作用于外部状态。ConcreteFlyweight实现Flyweight接口，ConcreteFlyweight对象必须是可共享的，它所存储的状态必须是内部的，即它必须独立于ConcreteFlyweight对象的场景。并非所有的Flyweight子类都需要被共享，FlyWeight接口使共享成为可能，但他并不强制共享。在Flyweight对象结构的某些层次，UnsharedConcreteFlyweight通常将ConcreteFlyweight对象作为子节点。FlyweightFactory创建并管理flyweight对象，确保合理地共享flyweight。Client维持一个对flyweight的引用，计算或存储一个（多个）flyweight的外部状态。

flyweight执行时所需的状态必定是内部的或外部的。内部状态存储于ConcreteFlyweight对象之中，而外部对象则由Client对象存储或计算。当用户调用flyweight对象的操作时，将该状态传递给它。

用户不应直接对ConcreteFlyweight类进行实例化，而只能从FlyweightFactory对象得到ConcreteFlyweight对象，这可以保证对他们适当地进行共享。

### 总结

适配器模式和桥接模式具有一些共同的特征。它们都给另一对象提供了一定程度上的间接性，因而有利于系统的灵活性。它们都涉及到从自身以外的一个接口向这个对象转发请求。它们的不同之处主要在于各自的用途。适配器模式主要是为了解决两个已有接口之间不匹配的问题。它不考虑这些接口是怎样实现的，也不考虑它们各自会如何演化。桥接模式则对抽象接口与它的（可能是多个）实现部分进行桥接。虽然这一模式允许你修改实现它的类，它仍然为用户提供了一个稳定的接口。

组合模式和装饰器模式有相似的结构图，说明它们都基于递归组合来组织可变数目的对象。同样，这两个模式目的不同。装饰器模式旨在使你能够不需要生成子类就能给对象添加职责，这避免了静态实现所有功能组合，从而导致子类数目急剧增加。组合模式旨在构造类，使多个相关的对象能够以统一的方式处理。它重点不在于修饰，而在于表示。尽管它们目的不同，但却具有互补性，通常协同使用。

另一种与装饰器模式相似的是代理模式。两者都描述了怎样为对象提供一定程度上的间接引用，代理对象和装饰器对象的实现部分都保留了指向利给一个对象的引用，它们向这个对象发送请求。然而同样，它们具有不同的设计目的。像装饰器模式一样，代理模式构成一个对象并为用户提供一致的接口。但与装饰器模式不同的是，代理模式不能动态地添加或分离性质，它也不是为递归组合而设计的。它的目的是，当直接访问一个实体不方便或不符合需要时，为这个实体提供一个替代者。代理模式中，实体定义了关键功能，而Proxy提供（或拒绝）对它的访问。在装饰器模式中，组件仅提供部分功能，而一个或多个Decorator负责完成其它功能。装饰器模式适用于编译时不能或不方便确定对象的全部功能的情况。这种开放性使得递归组合成为装饰器模式中一个必不可少的部分。而在代理模式中则不是这样，因为代理模式强调一种关系，这种关系可以静态的表达。

---

参考资料：

《设计模式：可复用面向对象软件的基础》

《大话设计模式》

[对设计模式的认识](http://www.cnblogs.com/loofywang/p/MyUnderstandingOfDesignPattern1.html)

[设计模式大杂烩](http://www.cnblogs.com/zuoxiaolong/p/pattern26.html)
