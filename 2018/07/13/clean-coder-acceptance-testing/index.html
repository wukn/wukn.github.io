<!DOCTYPE html>
<html lang="en">
<head>

  <meta charset="utf-8" />

  
  <title>[代码整洁之道]验收测试</title>

  
  





  
  <meta name="author" content="wukn" />
  <meta name="description" content=" 专业开发人员既要做好开发，也要做好沟通。“输入糟糕，输出也会糟糕”。职业程序员会重视与团队及业务部门的沟通，确保这种沟通的准确、顺畅。
 
" />

  
  
    <meta name="twitter:card" content="summary" />
    <meta name="twitter:site" content="@gohugoio" />
    <meta name="twitter:title" content="[代码整洁之道]验收测试" />
    <meta name="twitter:description" content=" 专业开发人员既要做好开发，也要做好沟通。“输入糟糕，输出也会糟糕”。职业程序员会重视与团队及业务部门的沟通，确保这种沟通的准确、顺畅。
 
" />
    <meta name="twitter:image" content="https://wukn.github.io/img/avatar.jpg" />
  

  
  <meta property="og:type" content="article" />
  <meta property="og:title" content="[代码整洁之道]验收测试" />
  <meta property="og:description" content=" 专业开发人员既要做好开发，也要做好沟通。“输入糟糕，输出也会糟糕”。职业程序员会重视与团队及业务部门的沟通，确保这种沟通的准确、顺畅。
 
" />
  <meta property="og:url" content="https://wukn.github.io/2018/07/13/clean-coder-acceptance-testing/" />
  <meta property="og:image" content="https://wukn.github.io/img/avatar.jpg" />




<meta name="generator" content="Hugo 0.46" />


<link rel="canonical" href="https://wukn.github.io/2018/07/13/clean-coder-acceptance-testing/" />
<link rel="alternative" href="https://wukn.github.io/index.xml" title="wukn blog" type="application/atom+xml" />


<meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<meta name="format-detection" content="telephone=no,email=no,adress=no" />
<meta http-equiv="Cache-Control" content="no-transform" />


<meta name="robots" content="index,follow" />
<meta name="referrer" content="origin-when-cross-origin" />







<meta name="apple-mobile-web-app-capable" content="yes" />
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
<meta name="apple-mobile-web-app-title" content="wukn blog" />
<meta name="msapplication-tooltip" content="wukn blog" />
<meta name='msapplication-navbutton-color' content="#5fbf5e" />
<meta name="msapplication-TileColor" content="#5fbf5e" />
<meta name="msapplication-TileImage" content="/img/tile-image-windows.png" />
<link rel="icon" href="https://wukn.github.io/img/favicon.ico" />
<link rel="icon" type="image/png" sizes="16x16" href="https://wukn.github.io/img/favicon-16x16.png" />
<link rel="icon" type="image/png" sizes="32x32" href="https://wukn.github.io/img/favicon-32x32.png" />
<link rel="icon" sizes="192x192" href="https://wukn.github.io/img/touch-icon-android.png" />
<link rel="apple-touch-icon" href="https://wukn.github.io/img/touch-icon-apple.png" />
<link rel="mask-icon" href="https://wukn.github.io/img/safari-pinned-tab.svg" color="#5fbf5e" />



<link rel="stylesheet" href="//cdn.bootcss.com/video.js/6.2.8/alt/video-js-cdn.min.css" />

<link rel="stylesheet" href="https://wukn.github.io/css/bundle.css" />


  
  <!--[if lt IE 9]>
    <script src="//cdn.bootcss.com/html5shiv/3.7.3/html5shiv.min.js"></script>
    <script src="//cdn.bootcss.com/respond.js/1.4.2/respond.min.js"></script>
    <script src="//cdn.bootcss.com/video.js/6.2.8/ie8/videojs-ie8.min.js"></script>
  <![endif]-->

<!--[if lte IE 11]>
    <script src="//cdn.bootcss.com/classlist/1.1.20170427/classList.min.js"></script>
  <![endif]-->


<script src="//cdn.bootcss.com/object-fit-images/3.2.3/ofi.min.js"></script>


<script src="//cdn.bootcss.com/smooth-scroll/12.1.4/js/smooth-scroll.polyfills.min.js"></script>


</head>
  <body>
    
    <div class="suspension">
      <a title="Go to top" class="to-top is-hide"><span class="icon icon-up"></span></a>
      
        
      
    </div>
    
    
  <header class="site-header">
  <img class="avatar" src="https://wukn.github.io/img/avatar.jpg" alt="Avatar">
  
  <h2 class="title">wukn blog</h2>
  
  <p class="subtitle">~ Stay Hungry, Stay Foolish ~</p>
  <button class="menu-toggle" type="button">
    <span class="icon icon-menu"></span>
  </button>
  <nav class="site-menu collapsed">
    <h2 class="offscreen">Main Menu</h2>
    <ul class="menu-list">
      
      
      
      
        <li class="menu-item
            
            
            
              is-active
            ">
            <a href="https://wukn.github.io/">Home</a>
          </li>
      
        <li class="menu-item
            
            
            ">
            <a href="https://github.com/wukn">Works</a>
          </li>
      
        <li class="menu-item
            
            
            ">
            <a href="https://wukn.github.io/tags">Tags</a>
          </li>
      
        <li class="menu-item
            
            
            ">
            <a href="https://wukn.github.io/about/">About</a>
          </li>
      
    </ul>
  </nav>
  <nav class="social-menu collapsed">
    <h2 class="offscreen">Social Networks</h2>
    <ul class="social-list">

      

      
      <li class="social-item">
        <a href="//github.com/wukn" title="GitHub"><span class="icon icon-github"></span></a>
      </li>

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      <li class="social-item">
        <a href="https://wukn.github.io/img/wechat_qrcode.png" title="Wechat"><span class="icon icon-wechat"></span></a>
      </li>

      

      

      

      

      <li class="social-item">
        <a href="https://wukn.github.io/index.xml"><span class="icon icon-rss" title="RSS"></span></a>
      </li>

    </ul>
  </nav>
</header>

  <section class="main post-detail">
    <header class="post-header">
      <h1 class="post-title">[代码整洁之道]验收测试</h1>
      <p class="post-meta">@wukn · Jul 13, 2018 · 1 min read</p>
    </header>
    <article class="post-content"><blockquote>
<p>专业开发人员既要做好开发，也要做好沟通。“输入糟糕，输出也会糟糕”。职业程序员会重视与团队及业务部门的沟通，确保这种沟通的准确、顺畅。</p>
</blockquote>

<p></p>

<h3 id="需求的沟通">需求的沟通</h3>

<p>开发方与业务方之间最常见的沟通是关于需求的。业务方描述他们认为自己需要的东西，程序员按照自己理解的业务方表达的需求来开发。至少从理论上来说，应该是这样。但是在现实里，关于需求的沟通是及其困难的，其中会出现各种问题。</p>

<h4 id="过早精细化">过早精细化</h4>

<p>做业务的人和写程序的人都容易陷入一个陷阱，即过早进行精细化。业务方还没有启动项目，就要精确知道最后能得到什么haifa方还没有评估整个项目，就希望精确知道要交付什么。双方都贪求不现实的精确性，而且经常愿意花大代价来追求这种精确。</p>

<p>（1）不确定原则</p>

<p>问题在于，东西画在纸上与真正做出来，是不一样的。业务方看到真正运行情况时就会意识到，自己想要的根本不是这样的。一看到已经满足的需求，关于到底要什么，他们就会冒出更好的想法——通常并不是他们当时看到的样子。</p>

<p>在工作中，有一种现象叫观察者效应，或者叫不确定原则。每次你想业务方展示一项功能，他们就获得了比之前更多的信息，这些新信息反过来又会影响他们对整个系统的看法。</p>

<p>最终结果就是，需求完成的越精细，就越容易被忽视，系统因此也谈不上完工。</p>

<p>（2）预估焦虑</p>

<p>开发人员也会掉进精细化的陷阱。他们知道必须评估整个系统，而且通常认为需要精确评估。但是，事实并非如此。</p>

<p>首先，即便拥有全面精确的信息，评估也通常会存在巨大的变数。其次，因为不确定原则的存在，不可能通过反复推敲实现早期的精确性。需求是一定会变化的，所以追求那种精确性是徒劳的。</p>

<p>专业开发人员知道，评估可以而且必须基于不那么精确的需求，这些评估只是评估而已。为强调这点，职业开发人员通常会在评估中使用误差棒（error bar），这样业务方就能理解不确定性。</p>

<h4 id="迟来的模糊性">迟来的模糊性</h4>

<p>避免过早精细化的办法是尽可能地推迟精细化。专业开发人员直到着手开发的前一刻才会把需求具体化。但是，这可能造成另一个问题：迟来的模糊性。</p>

<p>业务方常常会提出不同的意见。这时候他们会发现，相比解决分歧，更好的办法是换一种说法，所以会寻找各方都同意的关于需求的表述，而不是去解决争端。“需求文档中的每一点模糊之处，都对应着业务方的一点分歧。当然，模糊不只来自于分歧或争论。有时候，业务方会想当然地认为看文档的人懂得自己的意思”</p>

<p>专业开发人员必须确认，需求中没有任何不确定因素。这很困难，而且只有一种办法能解决。</p>

<h3 id="验收测试">验收测试</h3>

<p>有人认为，验收测试就是在接受正式发布之前由用户执行的程序，也有人认为它是QA测试。在这里，我们把验收测试定义为业务方与开发方合作编写的测试，其目的在于确定需求已经完成。</p>

<h4 id="完成-的定义">“完成”的定义</h4>

<p>身为专业开发人员，我们经常面对的不确定因素之一是“完成”的各种说法。开发人员所说的完成任务，是已经有足够信心把这项功能部署到生产系统，还是他可以准备QA程序，或者是他已经写完了代码并且跑通了但还没真正测试过？</p>

<p>完成意味着所有的代码都写完了，所有的测试都通过了，QA和需求方已经认可。这，才是完成。</p>

<p>那么，怎样能达到这种程度的完成，同时不影响迭代的速度呢？你应该编写整套的自动化测试，它们全部通过，就意味着满足了所有的要求。如果对功能的验收测试全部通过，就算真正完成了。</p>

<p>专业开发人员会根据自动化的验收测试来定义需求。他们与业务方和QA一起工作，确保自动化测试能够真正覆盖完成所需的各项指标。</p>

<h4 id="沟通">沟通</h4>

<p>验收测试的目的是沟通、澄清、精确化。开发方、业务方、测试方对验收测试达成共识。在专业开发人员看来，与业务方、测试方协同工作，确保大家都明白要做的是什么，是自己的责任。</p>

<h4 id="自动化">自动化</h4>

<p>验收测试都应当自动进行。在软件开发的周期中，确实有时候需要手动测试，但是验收测试不应当手工进行，原因很简单：要考虑成本。</p>

<p>专业开发人员认为，实现验收测试的自动化是自己的责任。</p>

<p>有许多开源的或商用的工具可以完成自动化的验收测试：FitNesse（作者的产品）、Cucumber、cuke4duke、robot framework、Selenium。</p>

<h4 id="额外工作">额外工作</h4>

<p>写那么多测试，看起来是大量额外工作。但是，写这些测试是为了确定系统的各项指标符合要求。确定这些细节指标的目的，是为了确定系统的指标；只有确定这些细节指标，我们这些程序员才能确知“完成”，业务方才能去儿女他们花钱开发的系统确实满足了需求，才可以真正做到自动化。所以这并不是额外工作，而应当看成节省时间和金钱的办法。</p>

<h4 id="验收测试什么时候写-由谁来写">验收测试什么时候写，由谁来写</h4>

<p>理想状态下，业务方和QA会协作编写这些测试，程序员检查测试之间是否有冲突或矛盾。实际上，业务方通常没有时间，后者有时间也难以达到所需要的细致程度，所以他们通常会吧测试交给业务分析人员、QA深圳是开发人员。如果只能由开发人员来写测试，应当确保写测试的程序员与开发所测试功能的程序员不是同一个人。</p>

<p>通常，业务分析人员测试“正确路径”，以证明功能的业务价值；QA则测试“错误路径”、边界条件、异常、例外情况，因为QA的职责是考虑哪些部分可能出问题。</p>

<p>遵循“推迟精细化”原则，验收测试应该越晚越好，通常是功能执行完成的前几天。在敏捷项目中，只有在选定了下一轮迭代或当前Sprint所需要的功能之后，才编写测试。</p>

<p>迭代开始的第一天，就应当准备好最初的几项验收测试。然后每天都应当完成一些验收测试，到迭代的中间点，所有的测试都应当准备完毕，如果这时候还没有准备好所有的测试，就必须抽调一些开发人员来补充编写测试。如果这种情况经常发生，这个团队应当增加BA或QA。</p>

<h4 id="开发人员的角色">开发人员的角色</h4>

<p>实现某项功能的代码，应该在对应的验收测试完成后开始。开发人员运行这些验收测试，观察失败的原因，将验收测试与系统联系起来，然后实现需要的功能，让测试通过。</p>

<h4 id="测试的协商与被动推进">测试的协商与被动推进</h4>

<p>写测试的人也是普通人，也可能犯错误。有些cedis没什么意义，有些太复杂，有些不灵活，还有写干脆就是错的。身为专业开发人员，与编写测试的人协商并改进测试是你的职责。决不能被动接受测试，更不能自我认为测试是这么要求的所以就得这么办。</p>

<p>身为专业的开发人员，你的职责是协助团队开发出最好的软件。也就是说，每个人都需要关心错误和疏忽，并协力改正。</p>

<h4 id="验收测试和单元测试">验收测试和单元测试</h4>

<p>验收测试不是单元测试。单元测试是程序员写给程序员的，它是正是的设计文档，描述了底层结构及代码的行为。关心单元测试结果的是程序员而不是业务人员。</p>

<p>验收测试是业务方写给业务方的（虽然可能最后是身为开发者的你来写）。它们是正是的需求文档，描述了业务方认为系统应该如何运行。关心验收测试结果的是业务方和程序员。</p>

<p>尽管单元测试和验收测试的对象通常是相同的，但绝不是重复。单元测试是深入系统内部进行，调用特定类的方法；验收测试则是在系统外部。通常是在API或者UI级别进行。所以两者的执行路径是不同的。两者不重复的根本理由是，它们的主要功能其实不是测试，测试只是它们的附属职能。单元测试和验收测试首先是文档，然后才是测试。它们的主要目的是如实描述系统的设计、结构和行为。</p>

<h4 id="持续集成">持续集成</h4>

<p>请务必确保在持续集成系统中，单元测试和验收测试每天都能运行好几次。整套持续集成系统应该由源代码管理系统来触发。只要有人提交了代码，持续集成系统就会开始构建，并运行所有的测试，测试结果会用电子邮件发送给团队所有人。</p>

<p>保持持续集成系统的时刻运行是非常重要的。持续集成不应该失败，如果失败了，团队里的所有人都应该停下手里的活，看看如何让测试通过。在持续集成系统里，失败的集成应该视为紧急情况，也就是“立刻中止”型事件。</p>

<h3 id="结论">结论</h3>

<p>要解决开发方和业务方沟通问题，我所知道的唯一有效的办法就是编写自动化的验收测试。这些测试足够正式，所以其结果有权威性。这些测试不会造成模糊，也不可能与真是系统脱节。它们，就是无可挑剔的需求文档。</p>

<hr />

<p>参考资料：</p>

<p>《代码整洁之道-程序员的职业素养》——Robert C. Martin</p></article>
    <footer class="post-footer">
      
      <ul class="post-tags">
        
          <li><a href="https://wukn.github.io/tags/coder"><span class="tag">Coder</span></a></li>
        
      </ul>
      
      <p class="post-copyright">
        © Creative Commons Attribution-NonCommercial 4.0 International License.
      </p>
    </footer>
    
      
    
  </section>
  <footer class="site-footer">
  <p>© 2017-2018 wukn blog</p>
  <p>Powered by <a href="https://gohugo.io/" target="_blank">Hugo</a> with theme <a href="https://github.com/laozhu/hugo-nuo" target="_blank">Nuo</a>.</p>
  
</footer>



<script async src="//cdn.bootcss.com/video.js/6.2.8/alt/video.novtt.min.js"></script>
<script async src="//cdn.bootcss.com/mathjax/2.7.2/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [['$','$'], ['\\(','\\)']],
      displayMath: [['$$','$$'], ['\\[','\\]']],
      processEscapes: true,
      processEnvironments: true,
      skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
      TeX: { equationNumbers: { autoNumber: "AMS" },
      extensions: ["AMSmath.js", "AMSsymbols.js"] }
    }
  });
</script>
<script type="text/x-mathjax-config">
  // Fix <code> tags after MathJax finishes running. This is a
  // hack to overcome a shortcoming of Markdown. Discussion at
  // https://github.com/mojombo/jekyll/issues/199
  MathJax.Hub.Queue(() => {
    MathJax.Hub.getAllJax().map(v => v.SourceElement().parentNode.className += ' has-jax');
  });
</script>

<script src="https://wukn.github.io/js/bundle.js"></script>


<script>
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'UA-XXXXXXXX-X', 'auto');
	
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>





  </body>
</html>
