<!DOCTYPE html>
<html lang="en">
<head>

  <meta charset="utf-8" />

  
  <title>[精耕]软件架构——软件的生命周期与软件架构</title>

  
  





  
  <meta name="author" content="wukn" />
  <meta name="description" content=" 一个软件，因为i某个业务的需要而产生，后续不断地更新、修改，推动软件逐渐变异、长大。当软件不再被需要（因业务的变化），或有更好的软件来替代时，该软件就会被废弃，完成使命而消亡。
 
" />

  
  
    <meta name="twitter:card" content="summary" />
    <meta name="twitter:site" content="@gohugoio" />
    <meta name="twitter:title" content="[精耕]软件架构——软件的生命周期与软件架构" />
    <meta name="twitter:description" content=" 一个软件，因为i某个业务的需要而产生，后续不断地更新、修改，推动软件逐渐变异、长大。当软件不再被需要（因业务的变化），或有更好的软件来替代时，该软件就会被废弃，完成使命而消亡。
 
" />
    <meta name="twitter:image" content="https://wukn.github.io/img/avatar.jpg" />
  

  
  <meta property="og:type" content="article" />
  <meta property="og:title" content="[精耕]软件架构——软件的生命周期与软件架构" />
  <meta property="og:description" content=" 一个软件，因为i某个业务的需要而产生，后续不断地更新、修改，推动软件逐渐变异、长大。当软件不再被需要（因业务的变化），或有更好的软件来替代时，该软件就会被废弃，完成使命而消亡。
 
" />
  <meta property="og:url" content="https://wukn.github.io/2018/05/06/architecutre-talks-software-lifecycle-and-architecture/" />
  <meta property="og:image" content="https://wukn.github.io/img/avatar.jpg" />




<meta name="generator" content="Hugo 0.40.3" />


<link rel="canonical" href="https://wukn.github.io/2018/05/06/architecutre-talks-software-lifecycle-and-architecture/" />
<link rel="alternative" href="https://wukn.github.io/index.xml" title="wukn blog" type="application/atom+xml" />


<meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<meta name="format-detection" content="telephone=no,email=no,adress=no" />
<meta http-equiv="Cache-Control" content="no-transform" />


<meta name="robots" content="index,follow" />
<meta name="referrer" content="origin-when-cross-origin" />







<meta name="apple-mobile-web-app-capable" content="yes" />
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
<meta name="apple-mobile-web-app-title" content="wukn blog" />
<meta name="msapplication-tooltip" content="wukn blog" />
<meta name='msapplication-navbutton-color' content="#5fbf5e" />
<meta name="msapplication-TileColor" content="#5fbf5e" />
<meta name="msapplication-TileImage" content="/img/tile-image-windows.png" />
<link rel="icon" href="https://wukn.github.io/img/favicon.ico" />
<link rel="icon" type="image/png" sizes="16x16" href="https://wukn.github.io/img/favicon-16x16.png" />
<link rel="icon" type="image/png" sizes="32x32" href="https://wukn.github.io/img/favicon-32x32.png" />
<link rel="icon" sizes="192x192" href="https://wukn.github.io/img/touch-icon-android.png" />
<link rel="apple-touch-icon" href="https://wukn.github.io/img/touch-icon-apple.png" />
<link rel="mask-icon" href="https://wukn.github.io/img/safari-pinned-tab.svg" color="#5fbf5e" />



<link rel="stylesheet" href="//cdn.bootcss.com/video.js/6.2.8/alt/video-js-cdn.min.css" />

<link rel="stylesheet" href="https://wukn.github.io/css/bundle.css" />


  
  <!--[if lt IE 9]>
    <script src="//cdn.bootcss.com/html5shiv/3.7.3/html5shiv.min.js"></script>
    <script src="//cdn.bootcss.com/respond.js/1.4.2/respond.min.js"></script>
    <script src="//cdn.bootcss.com/video.js/6.2.8/ie8/videojs-ie8.min.js"></script>
  <![endif]-->

<!--[if lte IE 11]>
    <script src="//cdn.bootcss.com/classlist/1.1.20170427/classList.min.js"></script>
  <![endif]-->


<script src="//cdn.bootcss.com/object-fit-images/3.2.3/ofi.min.js"></script>


<script src="//cdn.bootcss.com/smooth-scroll/12.1.4/js/smooth-scroll.polyfills.min.js"></script>


</head>
  <body>
    
    <div class="suspension">
      <a title="Go to top" class="to-top is-hide"><span class="icon icon-up"></span></a>
      
        
      
    </div>
    
    
  <header class="site-header">
  <img class="avatar" src="https://wukn.github.io/img/avatar.jpg" alt="Avatar">
  
  <h2 class="title">wukn blog</h2>
  
  <p class="subtitle">~ Stay Hungry, Stay Foolish ~</p>
  <button class="menu-toggle" type="button">
    <span class="icon icon-menu"></span>
  </button>
  <nav class="site-menu collapsed">
    <h2 class="offscreen">Main Menu</h2>
    <ul class="menu-list">
      
      
      
      
        <li class="menu-item
            
            
            
              is-active
            ">
            <a href="https://wukn.github.io/">Home</a>
          </li>
      
        <li class="menu-item
            
            
            ">
            <a href="https://github.com/wukn">Works</a>
          </li>
      
        <li class="menu-item
            
            
            ">
            <a href="https://wukn.github.io/tags">Tags</a>
          </li>
      
        <li class="menu-item
            
            
            ">
            <a href="https://wukn.github.io/about/">About</a>
          </li>
      
    </ul>
  </nav>
  <nav class="social-menu collapsed">
    <h2 class="offscreen">Social Networks</h2>
    <ul class="social-list">

      

      
      <li class="social-item">
        <a href="//github.com/wukn" title="GitHub"><span class="icon icon-github"></span></a>
      </li>

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      <li class="social-item">
        <a href="https://wukn.github.io/img/wechat_qrcode.png" title="Wechat"><span class="icon icon-wechat"></span></a>
      </li>

      

      

      

      

      <li class="social-item">
        <a href="https://wukn.github.io/index.xml"><span class="icon icon-rss" title="RSS"></span></a>
      </li>

    </ul>
  </nav>
</header>

  <section class="main post-detail">
    <header class="post-header">
      <h1 class="post-title">[精耕]软件架构——软件的生命周期与软件架构</h1>
      <p class="post-meta">@wukn · May 6, 2018 · 1 min read</p>
    </header>
    <article class="post-content"><blockquote>
<p>一个软件，因为i某个业务的需要而产生，后续不断地更新、修改，推动软件逐渐变异、长大。当软件不再被需要（因业务的变化），或有更好的软件来替代时，该软件就会被废弃，完成使命而消亡。</p>
</blockquote>

<p></p>

<h3 id="软件的生命周期">软件的生命周期</h3>

<p>软件的整个生命周期也会发生切分，从而形成两个子生命周期：软件开发生命周期和软件运行生命周期。哪一个才是真正的核心生命周期呢？软件开发生命周期的主体是软件开发，软件运行生命周期的主体是软件本身。所以软件运行生命周期才是核心生命周期，因为软件运行生命周期的主体和大的生命周期一致。而软件开发生命周期是为了产生软件，是为软件运行生命周期服务的。围绕着软件的生命周期，还会切分出许多其他的非核心生命周期。如：</p>

<p>（1）软件的开发生命周期。该周期的目的是产生可运行的软件，是可以切分出来单独管理的。内部还会发生切分，如需求生命周期、代码开发生命周期、测试生命周期等。</p>

<p>（2）软件的运行生命周期。软件的运行是我们真正需要的核心。在软件的生命周期中，可能会包含多个从启动到停止的生命周期。该生命周期又包含：</p>

<p>a.软件的访问生命周期。软件运行期间被访问，每次访问也是一个生命周期。</p>

<p>b.软件的功能生命周期。软件的内部功能被使用时，也是一个个生命周期，这个生命周期可能包含多个软件的访问生命周期。</p>

<p>c.软件的监控生命周期。在对软件运行状况进行监控时，就会形成软件的监控生命周期。软件第一次启动时，监控生命周期也随之开始；软件废弃，监控生命周期也随之结束。</p>

<h4 id="软件的开发生命周期">软件的开发生命周期</h4>

<p>软件的开发是根据业务需求来的，通常需要开发组织进行讨论，论证其必要性，确定代价和所获得价值的对比（ROI，Return On Investment）。从软件运行生命周期角度来说，一个可运行的独立部署单元才算是一个软件。</p>

<p>所以从开始决定生产一个软件，到软件真正地运行起来，会经历一段时间的代码积累，这个过程也是一个生命周期，就是软件的开发生命周期。这个生命周期以项目启动为始，然后和业务人员学习业务形成需求；接着根据需求完成编码，并测试代码是否达到业务模拟效果；测试通过后，再经由业务人员确认，部署上线。上线成功后，一个软件的开发生命周期结束。</p>

<h4 id="软件开发的增长">软件开发的增长</h4>

<p>软件工程师是开发生命周期中的关键人物，软件开发过程中的所有活动都是为了帮助软件工程师能够把代码写对，把业务虚拟出来。软件工程师首先必须要理解人是怎么在日常生活中完成业务工作的，然后才能把这些业务工作在计算机中用代码模拟出来。</p>

<p>就人类的学习过程来说，需要时间的积累。要成为某个领域的专家，需要一万个小时的训练（一万小时定律）。如果每天工作八个小时，一周工作五天，那么成为一个领域的专家至少需要五年。（每天十二小时、每周六天呢？答案是三年。然而，三年过去了，为什么我还没有成为领域内的专家呢。大概是因为写的都是重复性的业务代码吧。摊手&hellip;）</p>

<p>一个学习的判断标准是：学习一个东西如果只是能听懂，还不算学会；如果自己能够按照所学的执行，也才学会了一半；如果能够把自己所学的东西用自己的语言表达出来，让别人听懂，这才算差不多学会了。</p>

<p>要想对软件和计算机之外的行业业务实现模拟。软件工程师还要对该业务所在行业的专业知识进行一定的积累，并药超越听懂和能执行这两个阶段，才能够用另外一种语言，也就是计算机语言表达出来。这是一个相当高的要求。</p>

<p>软件工程师一旦进入比较复杂的业务领域，往往就会力不从心，因为业务已经超出了自身的能力。因此，软件开发的瓶颈需要被打破，需要引入大量的开发人员，慢慢开始就有了分工。例如，将行业知识剥离出来给熟悉业务的人员（BA，业务分析师），系统的设计交给架构师，设计的编码实现交给开发人员，编码结果的检验交给测试人员。还有很多其他角色来配合他们的工作，如项目经理。</p>

<p>无论是哪种切分或分工模式，即软件开发模式，其目标都是达到软件开发的增长。所有达到增长的手段，都是围绕软件开发核心生命周期进行切分的。不同的拆分方式，形成了不同的软件开发模式。</p>

<h4 id="软件开发的迭代">软件开发的迭代</h4>

<p>软件上线后，还会不断地进行修改。有的是因为要增加新的需求，有的是因为软件本身存在bug需要修复。此时软件会再走一遍软件开发流程，这就是软件开发的迭代。</p>

<p>因为迭代的存在，软件会产生不同的版本。每个版本的软件都是一个完整的开发生命流程。版本迭代的过程就是软件不断长大的过程。</p>

<p>由于软件开发是哟个独立的生命周期，可以与软件运行生命周期并行，因此可以做到多版本并行开发，以并行的方式提高生产力。这时就需要把代码的生命周期单独切分出来，以确保不同版本软件工程师之间的代码在时间和空间上不会产生冲突。</p>

<p>多版本并发又会产生上线冲突的问题。线上版本的运行是软件生命周期的核心，不管有多少个开发生命周期并行，线上版本只有一个。所以要排队上线，且确保后续的版本包含前一个线上版本的所有内容，这就形成了发布生命周期。</p>

<h4 id="软件的运行生命周期">软件的运行生命周期</h4>

<p>软件上线之后，其核心生命周期就启动了，软件开始服务于它的用户，知道软件停止为止。</p>

<p>在这期间，每一个用户对软件的访问，都是一个访问生命周期。软件功能的使用情况，也会形成功能的访问生命周期，这个生命周期往往和业务的子生命周期有关。</p>

<p>在软件启动后，运维会对它进行健康监测。业务也会针对该软件做业务监控，了解用户的使用情况，以便为下一步做好准备。</p>

<p>这些非核心生命周期，都形成了树状结构，围绕在软件核心生命周期周围，共同组成了软件的生命周期。</p>

<h3 id="什么是软件架构">什么是软件架构</h3>

<p>什么是软件架构呢？就是应用前述的办法，先尝试分析一下这个是什么问题，是谁的问题？利用生命周期分析，找到核心生命周期，以及核心生命周期的主体。</p>

<h4 id="要解决什么问题">要解决什么问题</h4>

<p>软件的目的是把现实生活模拟到计算机中，并且软件是需要在计算机的硬件中运行起来的。要做到这一点需要解决两个问题。</p>

<p>（1）业务的问题：在现实情况下，没有软件的时候，解决问题的主体是谁，解决的是什么问题，又是如何解决、如何运作的？</p>

<p>（2）计算机的问题：将开发和运行两个生命周期分开来看：</p>

<p>a.在软件开发生命周期中，如何用计算机语言来表达业务的生命周期？现实生活中业务生命周期是如何切分的？哪个是业务核心生命周期？哪些是业务非核心生命周期？业务生命周期拆分树是如何形成的？明确了这些问题的答案后，就可以明确软件的拆分，以及软件的内部组织。</p>

<p>b.在软件运行生命周期中，软件需要哪些硬件设施才能够满足要求？当访问量越来越大的时候，软件能否支持硬件的逐渐长大和性能线性扩展？硬件是可能会失效的，软件如何在硬件失效的情况下，仍然能够保证可用性，让用户能够不中断地访问软件提供的服务？如何收集软件产生的数据，为下一阶段的工作提供依据？</p>

<h4 id="分别是谁的问题呢">分别是谁的问题呢</h4>

<p>（1）业务的问题：业务的Owner需要提升业务的效率，提高生产力，降低业务的成本，这是动机。业务的Owner就是该问题的主体，软件开发的出发点就在这里，推动力也在这里。</p>

<p>（2）计算机的问题：软件生命周期负责的主体是软件工程师，因而要解决业务Owner吧业务虚拟化的问题，并且要解决软件开发和运行生命周期的问题。</p>

<h4 id="分别有什么问题">分别有什么问题</h4>

<p>（1）业务问题的本质是业务所服务对象的利益问题。根据业务对象的利益，可以整理出业务的生命周期和生命周期的拆分，再根据业务的概念和组织方式，可以分析出业务的核心生命周期。根据当前业务增长的方式，也可以反过来理解业务的生命周期拆分。通过对生命周期的分析，可以快速地理解业务，并进行领域建模，为软件模拟业务做好准备。</p>

<p>（2）软件工程师的问题本质，就是要用代码将业务模拟出来，形成软件，交给计算机运行。为了能够让业务在软件中很好地跑起来，软件工程师必须理解业务的生命周期、拆分方式，以及业务服务对象的利益所在，即业务问题。业务的核心生命周期是什么？面对这些问题是如何拆分解决的？涉及哪些概念？这些概念分别解决了哪些问题？针对这些问题，软件工程师经常根据自己的理解，创建一套概念体系来表述业务，或者用软件行业的术语来表述业务。如果这么做，会导致两个问题：</p>

<p>a.业务人员无法和软件工程师交流，因为他们无法理解软件工程师所创造的概念或者软件行业术语，也无法确认软件工程师的理解是否正确。</p>

<p>b.软件工程师所表述的东西，并没有在实际业务中实践过，业务人员也不知道这些概念时候能够解决业务的问题。如此一来，就可能出现不仅没有解决问题，还创造出了更多的问题。</p>

<p>（3）软件工程师还需要考虑，用什么样的硬件把软件跑起来？怎样才能跑得好、跑得快？并且软件还能随着业务的流量逐渐地长大？</p>

<h4 id="分析问题">分析问题</h4>

<p>面对前面所述的软件工程师的问题，在有限的时间内，简单地增加人员并不能有效地提高产出，还是需要分析业务的生命周期，通过拆分才能提升并行度。</p>

<p>（1）对于软件开发生命周期，也就是软件工程师的核心生命周期，需要完成以下事情：</p>

<p>a.学习业务知识，认识业务的生命周期，以及生命周期中所涉及的利益相关人的核心利益诉求。业务如何拆分、拆分后的核心生命周期是哪个、如何把它们组织起来？业务的运作流程涉及哪些概念、有哪些权力和责任等。</p>

<p>b.通过对业务知识的学习，确定核心生命周期和非核心生命周期，以及这些生命周期的组织方式。针对这些生命周期所对应的权力和责任以及组织架构，对业务进行建模，并把建模的结果用编程语言实现。这就是业务的运作模型。</p>

<p>c.理解参与业务的利益相关人是如何和业务打交道，并为每个角色的权力和义务进行代码描述并落地实现。</p>

<p>d.考虑如何把业务运行的结果持久化，并通过合适的手段吧持久化后的数据在合适的时间合适的地点夹在出来。</p>

<p>（2）对于软件运行生命周期，需要完成以下工作：</p>

<p>a.需要多少硬件设备来满足访问的需求？</p>

<p>b.软件要如何拆分并部署到哪些硬件设备上？</p>

<p>c.这些软件如何通过硬件设备互相连接在一起？</p>

<p>d.当业务流量增大到超过一台机器的容量时，软件能否支持通过部署到新增机器上的方式，扩大对业务的支撑？</p>

<p>e.当某台或某些硬件设备失效时，软件是否依然能够不影响用户的访问？</p>

<p>f.软件运行产生的数据，能否支持提取出来并加以分析，为下一轮的业务决策提供依据？</p>

<p>（3）针对这两个生命周期，还需要一个组织架构来实施代码的编写分工和软件运营的分工，需要确定的问题如下：</p>

<p>a.要想完成软件开发生命周期和软件运行生命周期所列出的这些事情，需要哪些角色参与？</p>

<p>b.这些事情基本都需要顺序地发生，如何保证信息在不同角色的传递过程中不会有损失？或者即使有损失也能快速纠正？</p>

<p>c.这些角色之间如何协调才能共同完成虚拟化业务的需求？</p>

<h4 id="什么是软件架构-1">什么是软件架构</h4>

<p>软件架构就是通过对软件生命周期的拆分，在符合业架构的前提下，以达到软件本省访问增长目的的方式。这个增长需要软件开发的增长，也需要软件运行的增长，因此达到所支撑业务的增长。</p>

<p>很多人认为架构是进化或演化出来的。进化的含义是由一个物种变成了另外一个物种，是本质的变化。架构追求的实际上是业务不断的长大：通过对业务生命周期的拆分，突出并精简业务核心生命周期，拆分出非核心生命周期，达到不同生命周期在空间和时间上并行。业务相当于基因，而架构树状拆分则相当于细胞的分裂。起决定作用的不是分裂本身，而是基因。</p>

<hr />

<p>参考资料：</p>

<p>《聊聊架构》——王概凯</p></article>
    <footer class="post-footer">
      
      <ul class="post-tags">
        
          <li><a href="https://wukn.github.io/tags/architecture"><span class="tag">Architecture</span></a></li>
        
      </ul>
      
      <p class="post-copyright">
        © Creative Commons Attribution-NonCommercial 4.0 International License.
      </p>
    </footer>
    
      
    
  </section>
  <footer class="site-footer">
  <p>© 2017-2018 wukn blog</p>
  <p>Powered by <a href="https://gohugo.io/" target="_blank">Hugo</a> with theme <a href="https://github.com/laozhu/hugo-nuo" target="_blank">Nuo</a>.</p>
  
</footer>



<script async src="//cdn.bootcss.com/video.js/6.2.8/alt/video.novtt.min.js"></script>
<script async src="//cdn.bootcss.com/mathjax/2.7.2/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [['$','$'], ['\\(','\\)']],
      displayMath: [['$$','$$'], ['\\[','\\]']],
      processEscapes: true,
      processEnvironments: true,
      skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
      TeX: { equationNumbers: { autoNumber: "AMS" },
      extensions: ["AMSmath.js", "AMSsymbols.js"] }
    }
  });
</script>
<script type="text/x-mathjax-config">
  // Fix <code> tags after MathJax finishes running. This is a
  // hack to overcome a shortcoming of Markdown. Discussion at
  // https://github.com/mojombo/jekyll/issues/199
  MathJax.Hub.Queue(() => {
    MathJax.Hub.getAllJax().map(v => v.SourceElement().parentNode.className += ' has-jax');
  });
</script>

<script src="https://wukn.github.io/js/bundle.js"></script>


<script>
window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
ga('create', 'UA-XXXXXXXX-X', 'auto');
ga('send', 'pageview');
</script>
<script async src='//www.google-analytics.com/analytics.js'></script>





  </body>
</html>
