---
title: "[精耕]代码整洁之道——单元测试"
author: "wukn"
tags: ["Code"]
catalog: true
date: 2018-06-20T22:00:00+08:00
url: /2018/06/20/clean-code-unit-test/

---

> 敏捷和TDD运动鼓舞了许多程序员编写自动化单元测试。单元测试能确保代码中的每个犄角旮旯能能如愿地工作。

<!--more-->

### TDD三定律

* **定律一** 在编写不能通过的单元测试前，不可编写生产代码。

* **定律二** 只编写刚好无法通过的单元测试，不能编译也算不通过。

* **定律三** 之编写刚好足以通过当前失败测试的生产代码。

这三条定律让我们产生这样一个循环：测试与生产代码一起写，测试代码只比生产代码早写几分钟。

### 保持测试整洁

**测试代码和生产代码一样重要**。正是单元测试让代码可扩展、可维护、可复用。原因很简单。有了测试，你就不担心对代码的修改。没有测试，每次修改都可能带来缺陷。无论架构多有扩展性，无论设计划分得有多好，没有了测试，你就很难做改动，因为你担心改动会引入不可预知的缺陷。而测试覆盖率越高，你就越不用担心。

如果测试代码不整洁，你改动代码的能力就有所牵制，而你也会开始失去改进代码结构的能力。测试越脏，代码就会变得越脏。最终，你丢失了测试，代码开始腐坏。

### 整洁的测试

整洁的测试有什么要素？有三个要素：可读性，可读性和可读性。在单元测试中，可读性甚至比在生产代码中还重要。测试如何才能做到可读？和其他代码一样：明确，简洁，还有足够的表达力。

每个测试都唔唔清晰地拆分为三个环节：构造测试数据——操作测试数据——检验操作是否得到期望的结果。

### 每个测试一个断言

有个流派认为，JUnit中每个测试函数都应该有且只有一个断言语句。这条规则看似过于苛刻，但是其好处也是显而易见的，每个测试都归结为一个可快速方便地理解的结论。

```java
public void testGetPageHierarchAxXml() throws Exception {
    givenPages("PageOne", "PageOne.ChildOne", "PageTwo");

    whenRequestIsIssued("root", "type:pages");

    thenResponseShouldBeXML();
}
```

这个例子符合given-when-then的约定。这让测试更易阅读。不幸的是，如此分解测试，导致了许多重复代码的出现。

可以利用模板方法模式，将given/when部分放到基类中，将then部分放到派生类中，消除代码重复问题。或者，也可以创建一个完整的单独测试类，把given和when部分放到@Before函数中，把when部分放到每个@Test函数中。这样对与这个小问题都显得有点太机械。

单个断言是个好准则，但是也不必过于苛求。我认为，最好的说法是单元测试中的断言数量应该最小化。

更好的规则或许是每个测试函数中只测试一个概念。

### FIRST原则

整洁的测试还遵循一下5条规则：

* **快速（Fast）** 测试应该够快。测试应该能快速运行，以便于频繁运行。

* **独立（Indenpendent）** 测试应该相互独立。某个测试不应为下一个测试设定条件。应该可以单独地运行每个测试，及以任何顺序运行测试。

* **可重复（Repeatable）** 测试应当可在任何环境中重复通过。

* **自足验证（Self-Validating）** 测试应该有布尔值输出。无论是通过还是失败，不应该查看日志文件来确认测试是否通过。如果测试不能自足验证，对失败的判断就会变得依赖主观，而运行测试也需要更长的手工操作时间。

* **及时（Timely）** 测试应及时编写。单元测试应该恰好在使其通过的生产代码之前编写。如果在编写生产代码之后编写测试，你会发现生产代码难以测试。

---

参考资料：

《代码整洁之道》——Robert C. Martin
