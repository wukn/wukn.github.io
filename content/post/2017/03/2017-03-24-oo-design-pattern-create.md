---
author: wukn
catalog: true
date: 2017-03-24T00:00:00Z
tags:
- 设计模式
title: '[设计模式]创建型模式'
url: /2017/03/24/oo-design-pattern-create/
---

> 创建型模式用于处理对象的创建。

> 创建型模式用各种方法创建或组合各种类型的对象,并向对象的使用者隐藏对象的创建过程。

<!--more-->

### Singleton（单例模式）

意图：保证一个类只有一个实例，并提供一个它实例的全局访问点。

对于一些类来说，只有一个实例是很重要的。怎样实现呢？使用一个全局变量可以使一个对象可被访问，但是它不能阻止实例化多个对象。

一个更好的办法是，让类自身负责保存他的唯一实例。这个类可以保证没有其他实例被创建（通过拦截创建新对象的请求），并且它可以提供一个访问该实例的方法。

![Singleton](/img/post/design-pattern/singleton.png)

类Singleton定义了一个Instance操作，允许用户访问它的唯一实例。Instance是一个类操作。同时Singleton可能负责创建它自己的唯一实例。

用户只能通过Singletonde Instance操作访问一个Singleton的实例。

### Factory Method（工厂方法模式）

意图：定义了一个创建对象的接口，由子类决定实例化哪个类，使一个类的实例化延迟到其子类。

设计原则：遵循单一职责、依赖倒置、开闭原则

适用于工厂方法模式的场景有：

* 当一个类不知道它所必须创建的对象的类的时候。
* 当一个类希望由它的子类来指定它所创建的对象的时候。
* 当类将创建对象的职责委托给多个帮助子类中的某一个，并且希望将哪一个帮助子类是代理这一信息局部化的时候。

![](/img/post/design-pattern/factory-method.png)

Product定义工厂方法所创建的对象的接口；ConcreteProduct实现Product接口；Creator声明工厂方法，该方法返回一个Product类型的对象，它也可以定义一个工厂方法的默认实现，返回一个默认的ConcreteProduct对象；ConcreteCreator重定义工厂方法以返回一个ConcreteProduct实例。

Creator依赖于它的子类来定义工厂方法，所以它返回一个适当的ConcreteProduct实例。

### Abstract Factory（抽象工厂模式）

意图：提供一个创建一系列相关或者相互依赖的对象的接口，但无需指定它们具体的类。

设计原则：遵循单一职责、依赖倒置、开闭原则

工厂方法模式与抽象工厂模式最大的区别在于，在工厂方法模式中，工厂创造的是一个产品，而在抽象工厂模式中，工厂创造的是一个产品族。

适用于抽象工厂模式的场景有：

* 一个系统要独立于它的对象的创建、组合和表示时。
* 一个系统要由多个产品系列中的一个来配置时。
* 当要强调一系列相关的产品对象的设计以便进行联合使用时。
* 当提供一個产品类库，只想显示它们的接口而不是实现时。

![](/img/post/design-pattern/abstract-factory.png)

AbstractFactory声明一个创建抽象产品对象的操作接口；ConcreteFactory实现创建具体产品对象的操作；AbstractProduct为一类产品对象声明接口；ConcreteProduct定义一个将被相应的具体工厂创建的产品对象，它实现了AbstractProduct接口。Client仅使用由AbstractFactory和AbstractProduct类声明的接口。

通常在运行时刻创建一个ConcreteFactory类的实例。这一具体的工厂创建具有特定实现的产品对象。为创建不同的产品对象，用户应使用不同的具体工厂。

AbstractFactory将产品对象的创建延迟到它的ConcreteFactory子类中。

### Builder（建造者模式）

意图：将一个复杂的对象的构建和它的表示分离，从而使相同的构建过程可以创建不同的表示。

设计原则：遵循单一职责、开闭原则

建造者模式是为了复用对象的构建过程，而抽象工厂模式是为了提供这批对象的创建接口而定义了抽象工厂接口。

适用于建造者模式的场景有：

* 当创建复杂对象的算法应该独立于该对象的组成部分以及它们的装配方式时。
* 当构造过程必须允许被构造的对象有不同的表示时。

![](/img/post/design-pattern/builder.png)

Builder为创建一个Product对象的各个部件指定抽象接口；Concretebuilder是具体建造者，实现Build接口，构造和装配各个部件，并提供一个检索产品的接口；Director是指挥者，它是构建一个使用Builder接口的对象；Product表示被构造的复杂对象；ConcreteProduct创建该产品的内部表示并定义它的装配过程。

建造者模式主要是用于创建一些复杂的对象，这些对象内部构建间的建造顺序通常是稳定的，但对象内部的构建通常面临着复杂的变化。

建造者模式的好处就是，使得建造代码和表示代码分离，由于建造者隐藏了该产品是如何组装的，所以若要改变一个产品的内部表示，只需要再定义一个具体的建造者就可以了。

### Prototype（原型模式）

意图：用原型实例来指定对象的类型，并且通过拷贝这个原型实例来创建对象。

当一个系统应该独立于它的创建、构成和表示时，要使用原型模式；以及：

* 为了避免创建一个与产品层次平行的工厂类层次时；或者
* 当一个类的实例只能有几个不同状态组合中的一种时。建立相应数目的原型并克隆它们可能比每次哟个合适的状态手动实例化该类更方便一些。

![](/img/post/design-pattern/prototype.png)

Prototype声明一个克隆自身的接口；ConcretePrototype实现一个克隆自身的操作；Client让一个原型克隆自身而创建一个新的对象。

原型模式与抽象工厂模式和建造者模式有很多相似之处，都对用户隐藏了具体的产品类。

实现克隆操作的时候需要注意浅拷贝和深拷贝。

### 总结

用一个系统创建的那些对象的类对系统进行参数化有两种常用方法。一种是生成创建对象的类的子类；这对应于工厂方法模式。这种方法的主要缺点是，仅为了改变产品类，就可能需要创建一个新的子类。这样的改变可能是级联的。例如，如果产品的创建者本身是由一个工厂方法创建的，那么也必须重定义它的创建者。

另一种对系统进行参数化的方法更多的依赖于对对象复合：定义一个对象负责明确产品对象的类，并将他作为该系统的参数。这是抽象工厂模式、建造者模式和原型模式的关键特征。所以这三个模式都涉及到创建一个新的负责创建产品对象的“工厂对象”。抽象工厂模式有这个工厂对象产生多个类的对象。建造者模式由这个公车过对象使用一个相对复杂的协议，逐步创建一个复杂产品。原型模式由该工厂对象通过拷贝原型对象来创建产品对象。在这种情况下，以内原型负责返回产品对象，所以工厂对象和原型是同一个对象。

使用抽象工厂模式、原型模式或建造者模式的设计甚至比使用工厂方法模式的那些设计更加灵活，但它们也更复杂。通常，设计以工厂方法开始，当发现需要更大的灵活性时，便向其他创建型模式演化。

---

参考资料：

《设计模式：可复用面向对象软件的基础》

《大话设计模式》

[对设计模式的认识](http://www.cnblogs.com/loofywang/p/MyUnderstandingOfDesignPattern1.html)

[设计模式大杂烩](http://www.cnblogs.com/zuoxiaolong/p/pattern26.html)
