---
author: wukn
catalog: true
date: 2017-03-09T00:00:00Z
tags:
- Python3
title: '[译][Python3] 序列'
url: /2017/03/09/python3-sequence/
---

> 序列类型（Sequence Types）是包含一组成员的连续列表，这些成员紧邻排列，并且可以通过序号（下标偏移量）访问其中的一个或多个成员。

基础的序列类型有：列表（list）、元组（tuple）和range。字符串（string）也是序列的一种。

<!--more-->

### 通用的序列操作

序列类型的一些通用操作如下：

* `x in s`：如果s中有个元素等于x则为True，否则为False
* `x not in s`：如果s中有个元素等于x则为False，否则为True
* `s + t`：连接s和t
* `s * n`或`n * s`：连接在一起的n个s的浅拷贝
* `s[i]`：s的第i个元素，索引从0开始
* `s[i:j]`：s中从第i个到第j个元素的切片
* `s[i:j:k]`：s中从第i个到第j个元素、步长为k的切片
* `len(s)`：s的长度，也就是s中元素的数量
* `min(s)`：s中最小的元素
* `max(s)`：s中最大的元素
* `s.index(x[, i[, j]])`	s中第一次出现的元素x的索引（在索引i或i之后，到j之前）	(8)
* `s.count(x)`：s中出现的元素x的次数

PS1:`s * n`或`n * s`中，n小于0时会被当作0，也就是返回一个跟s相同类型的空序列。

```python
>>> s = [1,2,3]
>>> s * 0
[]
>>> type(s)
<class 'list'>
>>> type(s * 0)
<class 'list'>
```

PS2:`s * n`或`n * s`中，复制为浅拷贝模式，嵌套的结构不会被拷贝过去。

```python
>>> s = [[]] * 3
>>> s
[[], [], []]
>>> s[0].append(3)
>>> s
[[3], [3], [3]]
```

因为`[[]]`是包含一个空列表元素的列表，由于是浅拷贝，`[[]] * 3`中的三个元素都指向同一个空列表。要想创建元素为不同类表的列表，可以这样：

```python
>>> lists = [[] for i in range(3)]
>>> lists[0].append(3)
>>> lists[1].append(5)
>>> lists[2].append(7)
>>> lists
[[3], [5], [7]]
```

PS3:序列支持负数索引。当索引i为负数时，相当于`len(s) + i`。也就是从序列的尾部开始计算，最后一个元素的索引为-1。如果i非负，那么0 <= i <= len(s)，如果i为负，那么-len(s) <= i <= -1，否则会引发索引越界异常。

```python
>>> s = [1,4,9,16,25]
>>> s[-1]
25
>>> s[-2]
16
```

PS4:`s[i:j]`切片操作，就是取索引k符合i <= k < j的所有元素。如果i或j大于s的长度len(s)，那么就取len(s)。如果i被省略了或者为None则取0;如果j被省略了或者为None则取len(s)。如果i大于或等于j，那么切片为空。

```python
>>> s = [1,4,9,16,25]
>>> s[1:2]
[4]
>>> s[2:10]
[9, 16, 25]
>>> s[:2]
[1, 4]
>>> s[3:]
[16, 25]
>>> s[4:4]
[]
```

PS5:带步长的切片`s[i:j:k]`，就是取索引x符合x = i + n*k 且0 <= n < (j-i)/k的所有元素。

> k不能为0；省略k或k为None时，令k=1
>
> k为正时
> * 如果省略i或i为None，则令i=0
> * 如果省略j或j为None，则令j=N
> * 如果i为负，则令i=i+N，此时如果i仍然为负，则令i=0；j类似
> * 如果i大于等于N，则令i=N；j类似
>
> k为负时
> * 如果省略i或i为None，则令i=N-1
> * 如果省略j或j为None，则令j=-1
> * 如果i为负，则令i=i+N，此时如果i仍然为负，则令i=-1；j类似
> * 如果i大于等于N，则令i=N-1；j类似
>
> 经过上述计算后，如果i、j、k的最终取值满足以下情况，则切片s[i:j:k]对应的子序列为空：
> * k为正，且i大于等于j
> * k为负，且i小于等于j

### 不可变序列类型（Immutable Sequence Type）

不可变序列类型有一个可变序列类型不支持的操作，那就是`hash()`。

这意味着不可变序列类型，例如元组实例，可以作为字典（dict）的键（key），且可以存储在set和frozenset实例中。

### 可变序列类型（Mutable Sequence Type）

可变操作类型还支持以下操作：

* `s[i] = x`：将s中第i个元素替换为x
* `s[i:j] = t`和`s[i:j:k] = t`：将切片替换为迭代器t的内容，t的长度必须和切片的长度一样
* `del s[i]`：删除s中第i的元素
* `del s[i:j]`：跟`s[i:j] = []`一样
* `del s[i:j:k]`：从s中移除切片中的元素
* `s.append(x)`：在序列的末尾添加x，相当于`s[len(s):len(s)] = [x]`
* `s.clear()`：移除s中的所有元素，相当于`del s[:]`
* `s.copy()`：创建一个s的浅拷贝，相当于`s[:]`
* `s.extend(t)`：将t的内容追加到s中，相当于`s[len(s):len(s)] = t`
* `s.insert(i, x)`：将x插入到s的索引i位置上，相当于`s[i:i] = [x]`
* `s.pop([i])`：获取索引i处的元素并将他从s中移除，i默认为-1
* `s.remove(x)`：移除s中第一个等于x的元素，如果x不再s中则会引发异常
* `s.reverse()`：颠倒s中元素的顺序，这个操作会直接修改s

PS:
* `enumerate(s)`	返回一个enumerate对象，该对象生成由(i, s[i])组成的元组
* `list(iter)`	把可迭代对象转换为列表
* `reversed(s)`	返回一个迭代器，访问该迭代器得到的序列与s逆序
* `sorted(s)`	返回一个列表，该列表是对s排序后的结果
* `str(obj)`	把对象转换为字符串（对象的字符串表示）
* `sum(s[, start])`	s中成员与start的总和（只能用于数值列表或数值元组，字符串用''.join(s)）
* `tuple(iter)`	把可迭代对象转换为元组
* `zip(s1, s2, ...)`	返回一个列表：[(s1[0], s2[0], ...), (s1[1], s2[1], ...), ...]
* `s.sort([cmp[, key[, reverse]]])`	对s进行排序

---

参考资料：

[Python3 Documentation](https://docs.python.org/3.5/)
